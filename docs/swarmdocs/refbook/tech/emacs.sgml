<SECT1 id="emacs.sect">
  <TITLE>Emacs and Objective C</TITLE>

  <PARA>Emacs is the world's best editor, infinitely configurable and
    powerful and free. If you're not used to a Unix text editor and want
    to write programs, emacs is probably best to learn. The information
    here will show you how to set up emacs to use an Objective C specific
    mode for editing source code and how to get emacs to colour your
    source code for you nicely. Emacs can also help you find compilation
    errors, run a debugger, and even act like a class browser. Docs for
    those things are not here, see the Emacs documentation itself.</PARA>
  
  <FORMALPARA>
    <TITLE>objc-mode</TITLE>
    <PARA>One of the best things about emacs is that one can load
      different "major modes" to edit types of files. Major modes making
      editing files easier by providing structure to your editing. In
      particular, there are programming language modes that do nice things
      like indentation for you.</PARA>
  </FORMALPARA>

  <PARA>Starting with emacs-19.30, the default C mode is
    cc-mode.el, a nice rewrite of the original
    c-mode.el. Luckily for us, cc-mode.el supports Objective C
    directly. The basic function to invoke it is
    <LITERAL>objc-mode</LITERAL>. The following bit of code in
    your .emacs will cause emacs to automatically enter
    objc-mode on all files that end in <LITERAL>.m</LITERAL> or
    <LITERAL>.h</LITERAL>:</PARA>

  <PROGRAMLISTING>
(setq auto-mode-alist
(append '(("\\.h$" . objc-mode)
("\\.m$" . objc-mode))))
  </PROGRAMLISTING>
  
  <FORMALPARA><TITLE>hilit19</TITLE>
    
    <PARA>Emacs running under X has the ability to colour your source code
      according to syntax. There are two packages to do this: font-lock and
      hilit19. I'm told font-lock is better, but I still use hilit19. Once
      you have hilit19 running in your emacs, you need to teach it how to
      highlight Objective C code. Here's what I use (cut and paste):
      
<PROGRAMLISTING>
;; modified objective c - get defuns, id.
(let ((comments     '(("/\\*" "\\*/" comment)))
(c++-comments '(("//.*$" nil comment)
("^/.*$" nil comment)))
(strings      '((hilit-string-find ?' string)))
(preprocessor '(("^#[ \t]*\\(undef\\|define\\).*$" "[^\\]$" define)
("^#.*$" nil include))))

(hilit-set-mode-patterns
'(objc-mode objective-C-mode)
(append
  comments c++-comments strings preprocessor
  '(
  ;; function decls are expected to have types on the previous line
  ("^\\(\\(\\w\\|[$_]\\)+::\\)?\\(\\w\\|[$_]\\)+\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+" nil defun)
  ("^\\(\\(\\w\\|[$_]\\)+[ \t]*::[ \t]*\\)?\\(\\(\\w\\|[$_]\\)+\\|operator.*\\)\\s *\\(\\(\\w\\|[$_]\\)+\\s *((\\|(\\)[^)]*)+" nil defun)
  ;; nelson - objective c style defuns
("^[-+].*{" nil defun)

  ("^\\(template\\|typedef\\|struct\\|union\\|class\\|enum\\|public\\|private\\|protected\\).*$" nil decl)
  ;; datatype -- black magic regular expression (nelson - add id)
  ("[ \n\t({]\\(\\(const\\|register\\|volatile\\|unsigned\\|extern\\|static\\)\\s +\\)*\\(\\(\\w\\|[$_]\\)+_t\\|float\\|double\\|void\\|char\\|short\\|int\\|unsigned\\|long\\|id\\|FILE\\|\\(\\(struct\\|union\\|enum\\|class\\)\\([ \t]+\\(\\w\\|[$_]\\)*\\)\\)\\)\\(\\s +\\*+)?\\|[ \n\t;()]\\)" nil type)

   ;; Objective C stuff: ^@[word] gets keyword colouring
   ("^@\\sw*" nil keyword)
   ;; key words
   ("[^_]\\<\\(return\\|goto\\|if\\|else\\|case\\|default\\|switch\\|break\\|continue\\|while\\|do\\|for\\|super\\|self\\)\\>[^_]" 1 keyword)))))
</PROGRAMLISTING>

  </FORMALPARA>
</SECT1>

<!--
Local Variables:
sgml-parent-document:("techcont.sgml" "SECT1")
End:
-->
