<sect1 id="swarm.user.user1.04.sect1">
  <title>The notion of a Swarm</title>

  <para>As explained in an earlier section, Swarm is designed for
    hierarchical creation of computer objects.  The observer swarm
    object is created first, and it creates a user interface and it
    also instantiates the model swarm, and the model swarm then
    creates levels below and schedules their activities.</para>

    <para>One of the original intentions of the Swarm project was to
    give users the ability to create high quality code with a minimum
    of fuss. The Swarm library creates a sequence of classes that
    accumulate and refine the ability to create simulation objects,
    manage memory for them, and schedule their activities.</para>

<sect2>
<title>Primary and Auxiliary Agents</title>

     <para>Terminology can cause confusion because computer
     programmers may use the term "agent" in a way that befuddles
     scientists. To the scientist, the term agent refers to a
     theoretically important entity that is modeled by a simulation.
     To a programmer, the term agent is usually broader, something
     like object.  As a result, there is sometimes slippage in a
     discussion of "agent-based modeling" because an understanding of
     the term agent is not shared.</para>

     <para>We intend to finesse this (big surprise!) by creating
     terminology for two kinds of agents.  This separation of agents
     into primary and auxiliary groups is created solely for
     discussion in this manual.  The idea is that primary agents are
     the ones that the research sets out to model in the first
     place. They are described in a theory, they have substantive
     importance.  Usually in this sense we have representations of
     important "actors" and one or more objects to represent the world
     in which they interact.</para>

     <para>To the surprise of most new users, it is often also necessary to
     create auxiliary agents that facilitate the work of the primary
     agents. For example, in a model of majority rule voting, one can
     have primary agents like voters and candidates. There may be a
     need for an auxiliary class called "Counter", a class that can
     spawn objects that can be used to tally the votes that are
     cast.</para>

     <para>In most cases, when we talk about multi-agent systems, we
     are referring to the primary agents.</para>

  </sect2>

<sect2>
 <title>The (Swarm) OOP way</title> 

    <para>Swarm models follow a common syntax that helps users to
    understand the way their parts interact. The observer swarm and
    the model swarm are typically designed in a similar way.  Methods
    that will appear in many classess, for example, include:

<programlisting>
-createBegin;
-createEnd;
-buildObjects;
-buildActions;
-activateIn
</programlisting>

      There are also methods that allow the input and output of
      information from the object. By custom, these are usually
      prefaced by the words "get" and "set". For example:

<programlisting>
-setParameterValue: (int) value;
-(int) getParameterValue;
</programlisting>

      These methods can be written to so that setParameterValue causes
      an object to set some internal parameter equal to a value, and
      getParameterValue will cause the agent to report back the
      value. </para>
 
    <para>In addition,there will be methods that carry out the
      specialized actions dictated by the substance of the research
      problem.</para>

     <para>The model swarm object is usually subclassed from Swarm and
     it is the primary object that is responsible for telling
     subclasses to build their agents. The model swarm also give those
     agents a place in memory, and schedules their activities.</para>

</sect2>

<sect2>
 <title>Managing memory in Swarms</title> 

    <para>The allocation and deallocation of memory is a necessary
    feature in any simulation project. Allocating and deallocating
    memory is one of the most troublesome elements of designing
    software and Swarm is well equipt to deal with that problem.
    Swarm provides libraries for this purpose which make the process
    transparent to user.</para>

    <para>In Swarm, objects are created and dropped using a notion of
    memory zones, and the "dirty work" of allocating memory is handled
    inside the libraries. In the next sections, we discuss the way
    objects are created and given a place in memory.  When those
    objects are no longer needed, the program can send that object the
    "drop" message, which removes it from memory.</para>
    

</sect2>

<sect2>
<title>What goes on in the "buildObjects" method?</title>

    <para>If the reader inspects just a few of the sample Swarm
      programs, the importance of the building objects should become
      apparent.  Objects are named and memory is set aside for them in
      this stage. In the buildObjects method, one typically finds
      commands that not only create the objects being used in the
      current class, but there will also be a command which instructs
      the next-lower level of agent to create its objects.</para>

    <para>Consider the rich example provided by the code from the
      Arborgames model. In the buildObjects method of the observer
      swarm, one finds a large number of commands that create
      graphical display objects (objects subclassed from the graph
      library).  One also finds commands that create the simulation
      control panel, which will appear on the screen and offer the
      user the ability to start and stop the simulation.</para>

    <para>It is vital to note also that the buildObjects method in the
      observer swarm file triggers the creation of the next lower
      level of agents.  It creates a memory zone and creates a model
      swarm in that memory zone. Using the current style, the code
      would look like so:</para>

<programlisting>
  forestModelSwarm = [ForestModelSwarm create: self ];  
  [forestModelSwarm buildObjects];
</programlisting>

   <para>Users may find older versions of this code which accomplish
      the same purpose, but are slightly more verbose and do not take
      into account the fact that the observer swarm object is iself a
      memory zone.</para>

<programlisting>
  modelZone = [Zone create: [self getZone]];
  forestModelSwarm = [ForestModelSwarm create: modelZone];  
  [forestModelSwarm buildObjects];
</programlisting>

    <para>Note the importance of the last line in either of these
      excerpts. The first line of the code creates the model swarm
      object (in this case, it is called forestModelSwarm), but the
      last line tells that object to create its own objects by telling
      the forestModelSwarm to execute its own buildObjects method.  To
      find out what that implies, one must go look in the
      implementation file for the ForestModelSwarm to see what objects
      it creates.</para>

</sect2>

<sect2>

    <title>What goes on in the "buildActions" method?</title>

    <para> In the standard case, the buildActions method has two
      important components.  It creates objects of these two classes.

      <itemizedlist>
        <listitem><para>ActionGroup: an unordered set of
            "simultaneous" events and </para></listitem>

      <listitem><para>Schedule: controls how often the elements in the
          action group are executed</para></listitem>

      </itemizedlist>

    </para>

    <para>In the buildActions methods of the Arborgames model, there
      are plenty of interesting examples.  In the observer swarm, for
      example, there are commands that schedule the updating of the
      graphical display and also there are commands that instruct the
      lower level classes to execute their own buildActions
      methods.</para>

    <para> In the model swarm's buildActions method, one typically
      finds the heart of the substantive action of the simulation.
      Commands tell agents, or lists of agents, that they should carry
      out their methods.  These commands are placed into instances of
      the ActionGroup class, which means that they will all be
      repeated whenever the group is repeated. The repetition is
      controlled by commands that create schedules and indicate how
      often those schedules will be repeated.</para>

</sect2>

<sect2>
 <title>A Swarm as a virtual computer</title> 

    <para>At an abstract level, the Swarm libraries cam be thought of
      as a layer on top of the operating system's kernel.

      <figure id="system-diagram.figure">
        <title>Swarm virtual computer</title>
        <graphic entityref="system-diagram"></graphic>
      </figure>
    </para>

    <para>A computer's CPU executes program instructions  </para>

    <para>Swarm</para>
      

    <formalpara><title>Nested Swarms merge schedules into one</title><para>
        CPU</para></formalpara>

</sect2>

<sect2>
<title>The Activity framework</title> 

    <para>Provides abstractions that allow programmer to treat event
      scheduling in the artificial world as objects, separate from
      elements of model
    </para>

    <para>Provide some useful shorthands to group actions and sort
      according to the desired order of events</para>

    <para>Since schedules are objects, all agents in simulation can
      communicate with them, to schedule future events or cause
      actions to be dropped based on specified contingencies </para>

</sect2>

<sect2>
 <title>Merging schedules in Swarms</title> 

    <para>As mentioned above, there can be "buildActions" methods in
      many different classes.  Since each one can create action groups
      and schedules, it is important that all of these activities are
      coordinated in a logical way.  One of the sstrengths of the
      Swarm toolkit is that it maintains a coherent, master
      schedule. The schedules of each sub Swarm are merged into the
      schedule of next higher level. Finally all schedules are merged
      in the top level Swarm</para>

    <para>This multi-level integration of swarm schedules means that
      the model can indeed be thought of as a nested hierarchy of
    models.</para>

</sect2>


</sect1>
<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "SECT1")
End:
-->
