<sect1 id="swarm.user.user2.02.sect1">
  <title>Creating Objects In Swarm</title>

  <para>The way in which objects are created depends on a computer's
    compiler and the software libraries available to the user. The
    implementation of Objective-C on a system using the GNU compiler
    will not be exactly the same as the implementation on a Next
    system.  While most of the points made in the literature on
    Objective-C easily carry over to Swarm modeling, the commands
    needed to create objects are an exception.  In the Objective-C
    manual for Next systems, for example, one finds a syntax methods
    <function>init</function> and <function>alloc</function> that are
    not used in Swarm.  That's why a brief study of object creation is
    important.
  </para>

  <sect2>
    <title>Begin at the beginning</title> 

    <para>
      Pick any Swarm application you like, such as Heatbugs.  Look in
      <filename>main.m</filename>. What do you find?  There's a check
      to see if the GUI mode or batch mode is to be run, and depending
      on that choice, either the <classname>ObserverSwarm</classname>
      or the <classname>BatchSwarm</classname> is designated as
      <varname>theTopLevelSwarm</varname>.</para> <para> Suppose we
      have do not do anything special when compiling and running the
      <application>heatbugs</application> executable, so the GUI mode
      is used.  In that case, the relevant code in
      <filename>main.m</filename> is this:

<programlisting>
if (swarmGUIMode == 1)
  {
  theTopLevelSwarm = [HeatbugObserverSwarm createBegin: globalZone];
  SET_WINDOW_GEOMETRY_RECORD_NAME (theTopLevelSwarm);
  theTopLevelSwarm = [theTopLevelSwarm createEnd];
}
</programlisting>

      The first command inside the brackets tells the class
      <classname>HeatbugObserverSwarm</classname> to execute its
      <function>createBegin</function> method and return an object
      which is to be named <varname>theTopLevelSwarm</varname>.  In
      this example, the <classname>HeatbugObserverSwarm</classname> is
      the class and also serves as a "factory object", an object that
      can build instances of its class.  The second command is a macro
      that saves window positions on subsequent runs of the program.
      It is set between the <function>createBegin</function> and
      <function>createEnd</function> methods because it is setting
      permanent features of the object
      <varname>theTopLevelSwarm</varname>.  The last command "seals"
      off the creation phase by telling the recently created object
      <classname>theTopLevelSwarm</classname> to run its
      <function>createEnd</function> method.
    </para>

    <para>
      In the Swarm Documentation, the methods that a class can execute
      are subdivided into categories, such as "CREATING," "SETTING"
      and "USING".  The methods or macros that appear under CREATING
      can only be used between <function>createBegin</function> and
      <function>createEnd</function>. Other commands that set values
      for instance variables need not be included between the
      <function>createBegin</function>/<function>createEnd</function>
      pair.
    </para>
  </sect2>

  <sect2>
    <title>Detailed look at
    <function>createBegin</function>/<function>createEnd</function></title>

    <para>
      Now take the next step and look at the
      <function>createBegin</function> and
      <function>createEnd</function> methods that are called by the
      code in <filename>main.m</filename>.  Follow the steps into
      <filename>HeatbugObserverSwarm.m</filename>.  Here you find the
      methods <function>+createBegin</function> and
      <function>-createEnd</function>.  The plus sign on
      <function>createBegin</function> indicates that this method
      cannot be executed by an instance of the class
      <classname>HeatbugModelSwarm</classname>, but rather only by the
      factory object.  Here is a portion of the method
      <function>createBegin</function>:

<programlisting>
+ createBegin: aZone
{
  HeatbugObserverSwarm *obj;
  id &lt;ProbeMap&gt; probeMap;
  obj = [super createBegin: aZone];
  obj->displayFrequency = 1;

  // [Code that creates "probemaps" omitted here]
  return obj;
}
</programlisting>

      This a good example of how the Swarm toolkit handles the
      creation of objects.  The pointer to the class
      <classname>HeatbugObserverSwarm</classname> named
      <classname>obj</classname> is defined.  Since
      <classname>HeatbugObserverSwarm</classname> is subclassed from
      GUISwarm, it is important to be sure that all of the important
      variables of a GUISwarm object are initialized and inherited by
      <classname>HeatbugObserverSwarm</classname>.  This is done in
      one step by telling the superclass to execute its
      <function>createBegin</function> method.  Since the classes are
      linked together in a hierarchy, each higher level class in turn
      executes its <function>createBegin</function> statement. That is
      how the instance of the class ends up setting values for all the
      variables that it inherits.
    </para>

    <para>
      The <function>createBegin</function> method of its superclass is
      told to put the created objects in <classname>aZone</classname>,
      which is the name of the space passed in from
      <filename>main.m</filename>.  The memory zone that is created is
      returned and set equal to obj. Then the <literal>return obj</literal> command
      gives back the created object to the calling code, in this case
      <filename>main.m</filename>, which then treats it as
      <varname>theTopLevelSwarm</varname>.  </para>

    <para> The reader can investigate in the Swarm source code to see
      that GUISwarm inherits through a hierarchical chain the ability
      to create memory zones and objects.  GUISwarm is subclassed from
      Swarm, which in turn inherits from CSwarmProcess.  That class is
      defined in the activity directory of the source code in a file
      called <filename>SwarmProcess.m</filename>.  This is the first
      place where you will find <function>createBegin</function> and <function>createEnd</function> methods as
      you move up the inheritance tree, so it must be that these are
      the methods that are executed when <classname>super</classname>
      is told to do something in this code.
    </para>

    <para>
      The <function>createEnd</function> method in
      <filename>HeatbugObserverSwarm.m</filename> is quite simple:

<programlisting>
- createEnd
{
  return [super createEnd];
}
</programlisting>

      In a case like this, when the super class is inside the Swarm
      library, it may be hard to figure out exactly why this command
      is needed. As a matter of fact, it is not necessary in this case
      at all, but it does not do any harm.  If it were omitted from
      this class, then this class would just inherit <function>createEnd</function> method
      from the somewhere above in the family tree.
    </para>

    <para>
      There are cases in which the <function>createEnd</function> statement may be more
      substantial.  In the <function>createBegin</function> phase, we typically find
      commands that set permanent features of objects.  Some methods
      that initialize instance variables can also be included. In the
      example above, the variable <varname>display frequency</varname> inside *obj is
      set equal to 1.  These variables are set at the first possible
      opportunity because other variables may depend on them.  After
      <filename>main.m</filename> calls the <function>createBegin</function> method,
      <filename>main.m</filename> may include statements that further
      tailor the state of the object and those commands may depend on
      values set in <function>createBegin</function>.  Finally, when
      <filename>main.m</filename> calls <function>createEnd</function>, a new slew of
      commands may be executed that define further elements of the
      object.  </para>

    <para>
      The <function>createEnd</function> statement may be a convenient place to put any
      code that completes the initialization of an object. For
      example, suppose inside there is a variable called
      <classname>age</classname>. In <function>createEnd</function>, one might find this:

<programlisting>
- createEnd
{
  [super createEnd];      
  age=0;
  return self;
}      
</programlisting>

      The super class is told to run its
      <function>createEnd</function> method, which will assure that
      any variables initialized there are set properly. Then the
      instance variable age is set equal to 0.  (Sometimes you will
      find examples in which <function>createEnd</function> is a
      "garbage can" that collects a large number of commands that set
      initial values for variables inside the object.  These commands
      might as well be regrouped and put into a new method inside the
      object that might be called
      <classname>setInitialValues</classname> that would be executed
      after the <function>createEnd</function>.  The readability of
      the code is enhanced that way.)
    </para>

    <para>
      The <function>create</function> message causes the receiver to
      carry out both its <function>createBegin</function> and
      <function>createEnd</function> methods.  Why didn't we always
      use <function>create</function>? Well, sometimes we need to
      define variables between the <function>createBegin</function>
      and <function>createEnd</function> steps, as seen in
      <filename>main.m</filename>. If there is no need to set values
      in that way (no methods marked with CREATING in the Swarm
      Documentation are used), then <function>create</function> is
      enough.
    </para>
  </sect2>

  <sect2>
    <title>Swarm zones and recursive objects creation</title> 
    <para>
      One of the most troublesome exercises in computer programming is
      the management of dynamically allocated memory. The correct
      usage of dynamic memory requires a great deal of care, and when
      a portion of memory is no longer needed, is must be "freed,"
      made available to the central processor.  If memory is allocated
      and then forgotten, a "memory leak" is said to exist because the
      program does not tell the operating system to reclaim unused
      memory addresses.  </para>

    <para>
      The Swarm libraries are designed to handle memory allocation
      with a minimum of user intervention. The
      <function>createBegin</function> and create commands allocate
      memory and the user is not expected to think about where the RAM
      comes from to store an object.  Similarly, when a program is
      finished with an object, that object can be sent the
      <function>drop</function> message and that should take care of
      freeing the memory that the object used.
    </para>

    <para>
      The create statements used in Swarm typically have this flavor:

<programlisting>
someUserCreatedObject = [SomeSwarmLibraryObject  create: someMemoryZoneHere];
</programlisting>

      (The method <function>create</function> can be replaced by a
      <function>createBegin</function>/<function>createEnd</function>
      pair as described above.)  More specific examples are discussed
      below and are of course scattered throughout the Swarm examples.
      The important thing is that an object in the Swarm library is
      able to respond to a method that creates an instance of itself
      and that instance lives in a memory zone that is managed by the
      Swarm library.
    </para>

    <para>
      In the <filename>main.m</filename> file, the top level Swarm is
      created and it is allocated into a zone called
      <classname>globalZone</classname>.

<programlisting>
theTopLevelSwarm = [HeatbugObserverSwarm createBegin: globalZone];
</programlisting>

      This globalZone is created inside the Swarm library, and the top
      level Swarm is told to create itself in that space. Any Swarm
      objects of type <classname>Swarm</classname> or
      <classname>GUISwarm</classname> are able to serve as memory
      zones. Inside the ModelSwarm one sees a command such as

<programlisting>
probeMap = [EmptyProbeMap createBegin: self];
</programlisting>
      This tells the EmptyProbeMap class in the Swarm library to
      create an instance of itself in the memory zone allocated by the
      ModelSwarm, and that allocated object is to be named <varname>probeMap.</varname>
    </para>

    <para>
      It often seems as if objects appear by "magic." It is more
      reasonable to say they are provided by the Swarm library in a
      way that is not entirely obvious.  For example, suppose you want
      to create a list of objects. One can declare an object
      <varname>listOfFriends</varname> and then create it, like so:

<programlisting>
id listOfFriends;
listOfFriends = [List create: self]; 
</programlisting>

      You see little bits like this all over example code from Swarm
      projects.  Where does this <classname>List</classname> class object
      come from and why are you able to make calls to it even though there
      is no import statement at the top of the program?  It seems as though,
      if you want to make a call on the List class, you ought to include
      <filename>List.h</filename> at the top of your file, right?  To use
      many of the Swarm classes, it is not necessary to use such an explicit
      import statement since you are not subclassing.  Explicit importing of
      a class header file is only required when you need to subclass from
      that file. The rules of thumb you should use are:

      <itemizedlist>

        <listitem><para>if you use a class that conforms to a protocol
            (such as <classname>List</classname>), where are actually
            instantiating an object directly, you need to include the
            header for that only for that library (in the above case
            it will be <filename>collections.h</filename>) wherever
            you reference that class that conforms to the protocol.
            This might required be in the header file
            <filename>.h</filename> or only in the implementation file
            <filename>.m</filename> (if you don't actually use the
            name of the protocol in the header
            file).</para></listitem>

        <listitem><para>if, however, you are
            <emphasis>subclasssing</emphasis> from a class that
            adheres to a protocol (say
            <classname>SwarmObject</classname>) you
            <emphasis>also</emphasis> need to include the actual
            header for that class.  In this example, it will be
            <filename>objectbase/SwarmObject.h</filename>.</para></listitem>

      </itemizedlist>

      As good coding practice, you should only ever have imports for header
      files for protocol definitions that you reference in that particular
      interface/implementation file pair.

    </para>

    <para>
      The objects at the top level of the swarm hierarchy have the
      power to "create space" for objects that live inside them.  As
      the code in <filename>main.m</filename> proceeds through the
      creation of <varname>theTopLevelSwarm</varname>, it is
      allocating memory and setting other important creation-state
      variables.  Then, that newly created object is told to go
      through its paces:

<programlisting>
[theTopLevelSwarm buildObjects];
[theTopLevelSwarm buildActions];
[theTopLevelSwarm activateIn: nil];
[theTopLevelSwarm go];
</programlisting>
    </para>

    <para>
      When you go look at the <function>buildObjects</function> method
      executed by the <varname>theTopLevelSwarm</varname>, what do you
      find? Depending on what edition of the Heatbugs source you have,
      you will find something like this:

<programlisting> 
heatbugModelSwarm = [HeatbugModelSwarm create: self];
</programlisting>

      In this code, the <varname>self</varname> is the observer level,
     meaning that the <classname>HeatbugModelSwarm</classname> class
     is told to create an instance of itself in the memory zone
     provided by the observer, and that allocated object is named
     <varname>heatbugModelSwarm</varname>.
    </para>

    <para>
      If you then follow the code into the
      <filename>HeatbugModelSwarm.m</filename> file, you find it has
      <function>createBegin</function> commands that initialize a
      number of instance variables and objects. Unless you have a
      pretty old piece of code, those objects will be created in the
      memory zone <varname>self</varname>, the space provided by the
      model swarm itself.
    </para>

    <para>
      Objects that are of type <classname>SwarmObject</classname> are
      not memory zones, and so when objects are created inside classes
      that inherit from <classname>SwarmObject</classname>, a command
      to allocate memory must be used.
<programlisting>
bugPixmap = [Pixmap createBegin: [self getZone]];
</programlisting>
 
     The <varname>bugPixmap</varname> object is created inside
      <filename>Heatbug.m</filename>, but the memory zone has to be
      retrieved with the <literal>[self getZone]</literal> command.
    </para>
  </sect2>

  <sect2>
    <title>Variations on a theme</title>
    <para>
      Once you have seen how an object can be created, you should
      start thinking about how your simulation will be organized.
      Within the standard Swarm approach, you begin with
      <filename>main.m</filename> allocating space for the top level
      swarm, which may be either a gui or batch swarm.  Then the model
      swarm object is created in that top level, and the model swarm
      in turn creates the substantively important objects that embody
      the model you seek to investigate.
    </para>

    <para>
      There are a number of different ways in which the creation of
      objects can be managed.  Some are more intuitive than others,
      some are more "reusable" than others. Since the first Swarm
      exercise for most people involves bugs, it is not surprising
      that many examples of Swarm code follow the convention of the
      bugs project.  As found in SimpleSwarmBug3, for example, the
      <filename>ModelSwarm.m</filename> file creates the bug objects
      in this way:

<programlisting>
- buildObjects
{
  Bug *aBug;
  int x, y;
  [some lines omitted here]
  bugList = [List create: self];

  for (y = 0; y < worldYSize; y++)
    for (x = 0; x < worldXSize; x++) 
     if ([uniformDblRand getDoubleWithMin: 0.0 withMax: 1.0] < bugDensity)
      {
      aBug = [Bug createBegin: self];
      [aBug setWorld: world Food: food];
      aBug = [aBug createEnd];
      [aBug setX: x Y: y];
  
      [bugList addLast: aBug];
      }
  
  reportBug = [bugList removeFirst];
  [bugList addFirst: reportBug];  
  return self;
}
</programlisting>

      This code cycles over the spaces in a lattice, and if the
      conditions are right, it causes the <classname>Bug</classname>
      class to create an instance of itself, called
      <varname>aBug</varname>, and then that instance is added to the
      <varname>bugList</varname>.
    </para>

    <para>
      Some changes can be made to make this code a little more
      versatile. For example, create a new method called
      <function>spawnOneBug</function> that moves out the bug creation
      steps.

<programlisting>
- buildObjects
{
  Bug *aBug;
  int x, y;
  [some lines omitted here]  
  bugList = [List create: self];

  for (y = 0; y < worldYSize; y++)
  for (x = 0; x < worldXSize; x++) 
  if ([uniformDblRand getDoubleWithMin: 0.0 withMax: 1.0] < bugDensity)
   {
    [self spawnOneBug];
   }
  
  reportBug = [bugList removeFirst];
  [bugList addFirst: reportBug];  
  return self;
}

- spawnOneBug
{

  aBug = [Bug createBegin: self];
  [aBug setWorld: world Food: food];
  aBug = [aBug createEnd];
  [aBug setX: x Y: y];
  [bugList addLast: aBug];

  return self;
}
</programlisting>

      Why is this more versatile?  By isolating the steps necessary to
      create a bug and add it to the <varname>bugList</varname> in the
      <function>spawnOneBug</function> method, we make it much easier
      to add new bugs to the simulation as time goes bye.
    </para>
  </sect2>

  <sect2>
    <title>How do you kill off those poor little devils?</title> 

    <para>
      If you look at Swarm examples for any amount of time, you can't
      help but run into objects that get dropped. Little "helper
      objects" like indexes for lists are created and just as readily
      discarded with the command

<programlisting>
  [someIndexName drop];
</programlisting>

      If everything goes the way it is supposed to, this should take
      the object out of memory and free that memory for the program to
      reuse.
    </para>

    <para>
      What if the objects inside your simulation are supposed to be
      born and killed through time? The Swarm bug tutorial mainly
      focuses on models in which a population of actors is created at
      the outset and those individuals remain in existence throughout
      the length of the program.  What if we wanted code to model a
      world in which the happy HeatBugs could reproduce themselves, or
      what if the unhappy ones could die and be freed from their never
      ending search for a place neither too cool or too hot?
    </para>

    <para>
      The Swarm <application>SugarScape</application> model provides
      an excellent example of a way to manage the birth and death of
      agents in an on-going model.  The <application>sss</application>
      model's <filename>ModelSwarm.m</filename> file contains the
      critical ingredients.  It has a method
      <function>addNewRandomAgent</function> which does what
      <function>spawnOneBug</function> does--it includes all the
      commands that create an instance of a
      <classname>SwarmObject</classname> and initializes
      it. <application>sss</application> also provides a handy
      structure to kill off agents and replace them with new ones.
      This is managed in a three stage process.  The model swarm
      creates a Swarm list object called
      <varname>reaperQueue</varname>.  When an event occurs that
      forces an object below the survival threshold, then that object
      is added to the <varname>reaperQueue</varname> by the
      <function>agentDeath</function> method.  Then the model Swarm's
      schedule includes a command that removes the dead agents from
      the <varname>reaperQueue</varname>.  The
      <function>reapAgents</function> method transverses the list of
      agents who are to die, it removes them from the list of active
      agents and then tells them to drop themselves from memory.

      <programlisting>

- agentDeath: (SugarAgent *)agent 
{
  [reaperQueue addLast: agent];
  if (replacement)				  // Replacement rule R (p.32)
    [self addNewRandomAgent];
  return self;
}

// remove all the agents on the reaperQueue from the agentList
// This allows us to defer the death of an agent until it's safe to
// remove it from the list.
- reapAgents 
{
  id index, agent;

  index = [reaperQueue begin: [self getZone]] ;
  while ((agent = [index next])) {
    [agentList remove: agent];
    [agent drop];
  }
  [reaperQueue removeAll];
  [index drop];
  return self;
}
</programlisting>

    </para>
  </sect2>
</sect1>
<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "SECT1")
End:
-->
