<chapter id="swarm.user.user1.03.chapter">
  <title>Nuts and bolts of Objective-C</title>

  <para>Objective-C was created by Brad Cox. The aim was to create an
    elegant, object-oriented extension of C in the style of the
    Smalltalk language. (need reference here).  Objective-C was used
    most intensively in the design of the NeXT computer operating
    system, which is now owned by Apple and is basis of the Rhapsody
    OS.</para>

<sect1>
 <title>Why does Swarm use Objective-C?</title> 

 <para>Since C++ is more widely used than Objective-C, it is natural
      to ask why the Swarm project chose Objective-C. There are a
      number of reasons.

      <itemizedlist>
       <listitem>
          
          <formalpara><title>Objective C is easier to learn</title>
            <para>Objective-C takes the familiar C language and adds a
              few simple elements. Objective-C does not allow
              overloading or multiple inheritance of classes (although
              the use of protocols enables this, to an extent)</para>
          </formalpara>

        </listitem>

	<listitem>
          <formalpara><title>Objective C allows run-time binding</title> 

            <para>Run-time binding is somewhat esoteric and
            controversial.  In contrast to other languages which check
            the match between the receiver of a command and its
            ability to carry out the command when a program is
            compiled, Objective-C leaves that matching exercise until
            the program is running.  This means, for example, that one
            can have a program that builds a list of objects and then
            sends a message to each one.  In Objective-C, the compiler
            won't worry about which type of object is in the list. The
            advantage, conceptually, is that one can put commands in
            their code without knowing the precise identity of the
            receiver, so code can be written to allow an environment
            and set of objects to change and evolve. The disadvantage,
            as critics of run-time binding will quickly point out, is
            that programs crash when an object recieves a message and
            it does not have the method that it is being told to
            execute.  The organization of the Swarm Toolkit into
            protocols reduces the risk of these crashes, however,
            because the compiler does check and issue a warning if a
            method is not implemented in a class that advertises a
            certain protocol.</para>
          </formalpara>
        </listitem> 
      </itemizedlist>

    </para>

</sect1>


<sect1>
 <title>The id variable type</title> 

    <para>The variable type that is added by Objective-C is
      <symbol>id</symbol>.  It is the default type for objects in
      Objective-C. Think of this as a special variable type (which is
      actually a pointer to a special data structure - namely the
      object)</para>

    <para>All objects can refer to themselves by using the label
      "self".  This is necessary if, in the code that defines the
      object, the programmer wants to make the object execute one of
      its methods.  For example, suppose an object has a method called
      "updateRecords".  If a command

        <programlisting role="ObjC">[self updateRecords];</programlisting>

      is received, then the updateRecords command will be executed,
      presumably to cause the updating of instance variables. </para>

    <para>All objects can refer to superclass by the name "super". For
      example,

<programlisting role="ObjC">[super updateRecords]</programlisting>

      </para>
</sect1>

<sect1>
 <title>Interface file: declaration of a class</title> 

    <para>If you look in a directory where some Swarm code resides,
      you will see files in pairs, such as ObserverSwarm.h and
      ObserverSwarm.m, ModelSwarm.h and ModelSwarm.m, and so forth.
      The "h" files are the interface files (commonly called "header
      files"), while the "m" files are the implementation files</para>

    <figure id="objc-basics.figure">
      <title>Objective C Basics</title>
      <graphic entityref="objc-basics"></graphic>
    </figure>


    <para>As illustrated in <xref linkend="objc-basics.figure">, the
      interface declares the name of the class and the name of its
      superclass.  Then it gives a list of variable types and names
      enclosed by braces ({}), and then the names of the methods that
      the class can implement are listed. The variables defined in
      this list can be used by any of the methods defined for the
      class.  (These are often called "ivars", short for instance
      variables.)
    <example id="swarm.user.user1.03.objc-class.example">
      <title>Objective C class</title>

      <programlistingco>
          <areaspec>
            <area coords="1 1" id="decl">
            <area coords="1 12" id="subclass">
            <area coords="1 18" id="superclass">
            <area coords="3 30" id="instance">
            <area coords="6 29" id="method1">          
            <area coords="7 8" id="method2">
          </areaspec>

<programlisting role="ObjC">
@interface Bug : SwarmObject {
  int xPos, yPos;
  int worldXSize, worldYSize;
  id foodSpace;
}
- setX: (int) x Y: (int) y;
- step;

@end</programlisting>
          
          <calloutlist>
            <callout arearefs="decl">
              <para>Declarations of instance variables and methods</para>
            </callout>
            <callout arearefs="subclass">
              <para>Sub class</para>
            </callout>
            <callout arearefs="superclass">
              <para>Super class</para>
            </callout>
            <callout arearefs="instance">
              <para>Instance Variables</para>
            </callout>
            <callout arearefs="method1">
              <para>declares method called <function>set</function> 
                that takes two arguments</para>
            </callout>
            <callout arearefs="method2">
            <para>declares a method called <function>step</function>.</para>
            </callout>

          </calloutlist>
        </programlistingco>
      </example>

    </para>

  </sect1>

<sect1>
 <title>Implementation File: Defining a class</title> 

    <para>Each implementation file--the "m" that parallels the "h"--
      must import its header file.  If the header file is called
      Puppy.h, for example, the implementation look like</para>

    <programlisting role="ObjC">
#import "Puppy.h"
@implementation  Puppy
- (vartype)eatFood 
{
 (body)
 return returnval;
}
- playOutside: (vartype)arg 
{
 (body)
 return self;
}
</programlisting>

 
    <para>This example shows a number of important features.  First,
    note that the method "eatfood" specifies a return type,
    (vartype). In this example, "vartype" would have to be replaced by
    a variable type, such as int, float, or whatever, and returnval
    would have to be a variable of that type. When that method is
    called, the receiving code must be able to accept a return of that
    type.  In contrast, the method "playOutside" does not specify a
    return type.  That means the default type, "id", is returned.  The
    code that calls this method must be consistent with that return
    type.</para>

    <para>The "return self" command is used for two types of
      situations.  Suppose the method is not intended to create any
      output, but rather it changes some instance variables. For
      example, suppose there is some program that creates an instance
      of Puppy called "spot". Then that object is sent this message:

<programlisting role="ObjC">[spot playOutside: theYard]
</programlisting>

      In such a case, the code that calls that method does not expect
      anything back from it.  Rather than fuss with (void) as the
      return type, as one might in C, one can simply include "return
      self".</para>

      <para>In another case, one might actually intend to return the
      object to a list or another object. In such a case, return self
      will also be appropriate. If one is making a list of puppies
      that have indeed played in the yard, for example, then the usage
      of "return self" in that method will give back spot's id to the
      calling program. To be perfectly concrete about it, suppose the
      calling code has a list called "dogsPlayed."  Then using the
      "addLast" notation from the Swarm collections library, the
      command to add spot to the list after playing outside miht look
      like this:

 <programlisting role="ObjC">[dogsPlayed addLast: [spot playOutside: theYard]];
</programlisting>
 </para> 
</sect1>

<sect1>
 <title>C Functions vs. Objective-C methods </title> 

    <para>For readers who are already familiar with C, perhaps a
      comparison of C functions against Objective-C methods is in
      order. Since Objective-C is a superset of C, an Objective-C
      method can include any valid C commands. A method can return any
      type that a C function can return, and in addition it can an id
      (which, strictly speaking, is a pointer to an object).  </para>

    <para>In the abstract, an Objective-C method has this structure:</para>
    
<programlisting role="ObjC">
- (type)name: (type)arg1 argName2: (type)arg2 
{
 (body)
 return returnval;
}
</programlisting>

    <para>In comparison, a C function would look like this:</para>

    <programlisting role="C">
(type)name((type) arg1,(type) arg2)) 
{
 (body)
 return returnval;
}
</programlisting>

    <para>The code in body of an Objective-C method can be exactly the
    same as in C.  The two languages are compared side-by-side in the
    following example, which describes how a function "rand_move()"
    might compare to a method "rand_move:".  Of course, each of these
    assumes there are other functions and variables that can be
    accessed, but the contrast in style should be informative.
    
      <example id="swarm.user.user1.03.c-vs-objc.example">
        <title>C vs Objective-C</title>

        <programlisting role="C">
void rand_move(int i) {    

 int tmp_loc;

 do{
 tmp_loc=get_rand_loc();
 } while(val[tmp_loc]!=0);

 val[location[i]]=0;
 val[tmp_loc]=i;
}
</programlisting>

    <programlisting role="ObjC">
- rand_move: p 
{
  id loc;

  do{
   loc=[self getRandLoc];

  } while([world at: loc]!=nil);

 [p moveTo: loc];
 return self;
}
</programlisting>

      </example>
    </para>

</sect1>

<sect1><title>Giving life to classes: instantiation</title>

    <para>After the code is written for the interface and
      implementation, there is still work to be done. Instances of the
      class must be created. The creation of instances of a class is
      one of the specialized features of Swarm. Since the
      instantiation process is different from the that described in
      the Objective-C literature, it is worth some special
      attention.</para>

    <para>The creation of the substantively important objects is often
    handeled in the model swarm.  This process uses the specialized
    memory management and object creation code in the Swarm
    library.</para>

    <para> The objects that represent the actors in a simulation--the
    substantively important entities--are usually subclassed from the
    SwarmObject class. The "inheritance hierarchy" that leads to the
    class SwarmObject passes through classes that allow the creation
    and deletion of objects from a simulation.  Objects are often
    created by a pair of "bookend" commands, createBegin and
    createEnd. This is not part of the Objective-C syntax.  Rather, it
    is unique to Swarm. </para>

    <para>Suppose the Puppy.h and Puppy.m files exist, and one wants
      to create an instance of that class.  In a file ModelSwarm.m,
      one would typically have a method called "buildObjects", which
      is usually a method that houses all object creation. For
      example:

<programlisting role="ObjC">
//Excerpt from ModelSwarm.m that creates a puppy instance
     #import "Puppy.h"
     {other imports and code that defines agents, schedules, etc}
-buildObjects {    
       Puppy * puppy;
       puppy = [Puppy createBegin: self ];
       {commands that set permanent features of the puppy can apppear here}
       puppy = [puppy createEnd];
}
</programlisting>

      The class's "factory object", Puppy, is told to create an object
      in a memory zone that is provided by ModelSwarm (ModelSwarm is
      the "self."). Then the object "puppy" is
      instructed to finish the creation process, after optional
      commands are added to define the features of the object
      (typically, to set values of the object's instance
      variables). Many of these subtleties are explained in depth in
      later sections.</para>

    <para>Not all object instances are created by the
      createBegin/createEnd pair. Some of the built-in objects can be
      created by a simple create command.  For example, the Swarm
      collections library includes a class called "List".  If one
      needs to create an object from that class, a command like this
      will work in ModelSwarm.m:

<programlisting role="ObjC">
id listOfPuppies;
listOfPuppies=[List create: self];

</programlisting>
</para>

     <para>In code written for older versions of the Swarm toolkit,
      one will often see a slightly different syntax in ModelSwarm.m:

<programlisting role="ObjC">
id listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

     This usage is still valid, although it is deprecated.  Since now
     the objects of type Swarm, like the model swarm itself, are
     memory zones, there is no need to get a zone in which to put the
     list.  Rather, the list can be put in the zone that is provided
     by the model swarm itself.
    </para>

</sect1>

<sect1><title>A brief clarification: Classes and Protocols</title>

    <para>There is one additional complication that readers should be
      aware of.  Objective-C allows the creation of entities called
      protocols.  A protocol, as readers will recall from their study
      of Objective-C, is a list of methods that an object is able to
      execute.  The Swarm Toolkit is structured by protocols, which
      means that there are lists of methods assigned to various names
      and classes inside the library "adopt" those protocols and then
      implement the methods listed in the protocols.  Hence, in the
      Swarm Reference materials present the libraries as a collection
      of classes, each of which adheres to a given set of
      protocols. </para>

    <para>To the Swarm user, the distinction between class and
      protocol is not vital most of the time.  The most important
      Swarm objects, such as the type Swarm (from
      <filename>objectbase/Swarm.h</filename>) or SwarmObject (from
      <filename>objectbase/SwarmObject.h</filename>), are classes from
      which users subclass to make model swarms or individual
      agents. It should not matter to the user that these classes have
      adopted protocols (taken on the obligation to implement methods
      listed in protocols).  The class SwarmObject, for example,
      adopts protocols Create and Drop. This means that objects from
      SwarmObject Class have the ability to execute methods like
      createBegin, createEnd, or drop.  Users who create classes using
      SwarmObject inherit these methods. One of the principal
      advantagesof protocol usage is that there will be compile-time
      warnings if a class does not implement a method that is listed
      in a protocol that the class adopts.  In a crude way, adopting a
      protocol is like advertising that a class can do certain things,
      and the compiler enforces a 'truth in advertising'
      policy. </para>

    <para>The fact that many of the important components of the Swarm
      library are organized as protocols can, however, be important in
      some notation. Early versions of Swarm had less emphasis on
      protocals than the current version.  As a result of the
      introduction of protocols, usage conventions have changed.  In
      Swarm, there is a class List that can be used to create
      collections.  In the "old days" of swarm, one would create a
      statically typed object of class List, as this code indicates:


<programlisting role="ObjC">
List * listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

      In contrast, when the List class advertises that it adopts the
      List protocol, the notation to define the type is different.  If
      one needs to define a variable listOfPuppies that has the
      properties of a List class item, the recommended approach is to
      create a variable of type id and indicate the protocols adopted
      by that object in brackets:


<programlisting role="ObjC">
id &lt; List &gt;  listOfPuppies;
listOfPuppies=[List create: [self getZone]];
      </programlisting>
    </para>

    <para>Since almost all of the important pieces of functionality in the
      Swarm library are now written in the protocol format, these
      details may be important in coding details. However, these details do not
      significantly change the way applications are designed.</para>

</sect1>
</chapter>

<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "CHAPTER")
End:
-->
