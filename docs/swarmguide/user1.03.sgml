<sect1 id="swarm.user.user1.03.sect1">
  <title>Nuts and bolts of Objective-C</title>

  <para>Objective-C was created by Brad Cox. The aim was to create an
    elegant, object-oriented extension of C in the style of the
    Smalltalk language. (need reference here).  Objective-C was used
    most intensively in the design of the NeXT computer operating
    system, which is now owned by Apple and is basis of the Rhapsody
    OS.</para>

<sect2>
 <title>Why does Swarm use Objective-C?</title> 

 <para>Since C++ is more widely used than Objective-C, it is natural
      to ask why the Swarm project chose Objective-C. There are a
      number of reasons.

      <itemizedlist>
       <listitem>
          
          <formalpara><title>Objective C is easier to learn</title>
            <para>Objective-C takes the familiar C language and adds a
              few simple elements. Objective-C does not allow
              overloading or multiple inheritance of classes (although
              the use of protocols enables this, to an extent)</para>
          </formalpara>

        </listitem>

	<listitem>
          <formalpara><title>Objective C allows run-time binding</title> 

            <para>Objective-C leaves open the possibility that ???.
              At the time the Swarm project began, C++ did not allow
              this</para>
          </formalpara>
        </listitem> 
      </itemizedlist>

    </para>

</sect2>


<sect2>
 <title>The id variable type</title> 

    <para>The variable type that is added by Objective-C is
      <symbol>id</symbol>.  It is the default type for objects in
      Objective-C. Think of this as a special variable type (which is
      actually a pointer to a special data structure - namely the
      object)</para>

    <para>All objects can refer to themselves by using the label
      "self".  This is necessary if, in the code that defines the
      object, the programmer wants to make the object execute one of
      its methods.  For example, suppose an object has a method called
      "updateRecords".  If a command

        <programlisting>[self updateRecords];</programlisting>

      is received, then the updateRecords command will be executed,
      presumably to cause the updating of instance variables. </para>

    <para>All objects can refer to superclass by the name "super". For
      example,

<programlisting>[super updateRecords]</programlisting>

      </para>
</sect2>

<sect2>
 <title>Interface file: declaration of a class</title> 

    <para>If you look in a directory where some Swarm code resides,
      you will see files in pairs, such as ObserverSwarm.h and
      ObserverSwarm.m, ModelSwarm.h and ModelSwarm.m, and so forth.
      The "h" files are the interface files (commonly called "header
      files"), while the "m" files are the implementation files</para>

    <para>As illustrated in figure xxx (Benedikt "A few Objective-C
      basics), the interface declares the name of the class and the
      name of its superclass.  Then it gives a list of variable types
      and names enclosed by braces ({}), and then the names of the
      methods that the class can implement are listed. The variables
      defined in this list can be used by any of the methods defined
      for the class.  (These are often called "ivars", short for
      instance variables.)(Benedikt "Declaring a Class")</para>

  </sect2>

<sect2>
 <title>Implementation File: Defining a class</title> 

    <para>Each implementation file--the "m" that parallels the "h"--
      must import its header file.  If the header file is called
      Puppy.h, for example, the implementation look like</para>

    <programlisting>
#import "Puppy.h"
@implementation  Puppy
- (vartype)eatFood 
{
 (body)
 return returnval;
}
- playOutside: (vartype)arg 
{
 (body)
 return self;
}
</programlisting>

 
    <para>This example shows a number of important features.  First,
    note that the method "eatfood" specifies a return type,
    (vartype). In this example, "vartype" would have to be replaced by
    a variable type, such as int, float, or whatever, and returnval
    would have to be a variable of that type. When that method is
    called, the receiving code must be able to accept a return of that
    type.  In contrast, the method "playOutside" does not specify a
    return type.  That means the default type, "id", is returned.  The
    code that calls this method must be consistent with that return
    type.</para>

    <para>The "return self" command is used for two types of
      situations.  Suppose the method is not intended to create any
      output, but rather it changes some instance variables. For
      example, suppose there is some program that creates an instance
      of Puppy called "spot". Then that object is sent this message:

<programlisting>[spot playOutside: theYard]
</programlisting>

      In such a case, the code that calls that method does not expect
      anything back from it.  Rather than fuss with (void) as the
      return type, as one might in C, one can simply include "return
      self".</para>

      <para>In another case, one might actually intend to return the
      object to a list or another object. In such a case, return self
      will also be appropriate. If one is making a list of puppies
      that have indeed played in the yard, for example, then the usage
      of "return self" in that method will give back spot's id to the
      calling program. To be perfectly concrete about it, suppose the
      calling code has a list called "dogsPlayed."  Then using the
      "addLast" notation from the Swarm collections library, the
      command to add spot to the list after playing outside miht look
      like this:

 <programlisting>[dogsPlayed addLast: [spot playOutside: theYard]];
</programlisting>
 </para> 
</sect2>

<sect2>
 <title>C Functions vs. Objective-C methods </title> 

    <para>For readers who are already familiar with C, perhaps a
      comparison of C functions against Objective-C methods is in
      order.</para>

    <para>Objective-C method:</para>
    
<programlisting>
- (type)name: (type)arg1 argName2: (type)arg2 
{
 (body)
 return returnval;
}
</programlisting>

    <para>C function:</para>

    <programlisting>
(type)name((type) arg1,(type) arg2)) 
{
 (body)
 return returnval;
}
</programlisting>

    <para>Code in body could look exactly the same in C and
      Objective-C.  The two languages are compared side-by-side in
      figure (Benedikt "An example of C vs ObjC")</para>

</sect2>

<sect2><title>Giving life to classes: instantiation</title>

    <para>After the code is written for the interface and
      implementation, there is still work to be done. Instances of the
      class must be created. The creation of instances of a class is
      one of the specialized features of Swarm. Since the
      instantiation process is different from the that described in
      the Objective-C literature, it is worth some special
      attention.</para>

    <para>The creation of the substantively important objects is often
    handeled in the model swarm.  This process uses the specialized
    memory management and object creation code in the Swarm
    library.</para>

    <para> The objects that represent the actors in a simulation--the
    substantively important entities--are usually subclassed from the
    SwarmObject class. The "inheritance hierarchy" that leads to the
    class SwarmObject passes through classes that allow the creation
    and deletion of objects from a simulation.  Objects are often
    created by a pair of "bookend" commands, createBegin and
    createEnd. This is not part of the Objective-C syntax.  Rather, it
    is unique to Swarm. </para>

    <para>Suppose the Puppy.h and Puppy.m files exist, and one wants
      to create an instance of that class.  In a file ModelSwarm.m,
      one would typically have a method called "buildObjects", which
      is usually a method that houses all object creation. For
      example:

<programlisting>
//Excerpt from ModelSwarm.m that creates a puppy instance
     #import "Puppy.h"
     {other imports and code that defines agents, schedules, etc}
-buildObjects {    
       Puppy * puppy;
       puppy = [Puppy createBegin: self ];
       {commands that set permanent features of the puppy can apppear here}
       puppy = [puppy createEnd];
}
</programlisting>

      The class's "factory object", Puppy, is told to create an object
      in a memory zone that is provided by ModelSwarm (ModelSwarm is
      the "self."). Then the object "puppy" is
      instructed to finish the creation process, after optional
      commands are added to define the features of the object
      (typically, to set values of the object's instance
      variables). Many of these subtleties are explained in depth in
      later sections.</para>

    <para>Not all object instances are created by the
      createBegin/createEnd pair. Some of the built-in objects can be
      created by a simple create command.  For example, the Swarm
      collections library includes a class called "List".  If one
      needs to create an object from that class, a command like this
      will work in ModelSwarm.m:

<programlisting>
id listOfPuppies;
listOfPuppies=[List create: self];

</programlisting>
</para>

     <para>In code written for older versions of the Swarm toolkit,
      one will often see a slightly different syntax in ModelSwarm.m:

<programlisting>
id listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

     This usage is still valid, although it is deprecated.  Since now
     the objects of type Swarm, like the model swarm itself, are
     memory zones, there is no need to get a zone in which to put the
     list.  Rather, the list can be put in the zone that is provided
     by the model swarm itself.
    </para>

</sect2>

<sect2><title>A brief clarification: Classes and Protocols</title>

    <para>There is one additional complication that readers should be
      aware of.  Objective-C allows the creation of entities called
      protocols.  A protocol, as readers will recall from their study
      of Objective-C, is a set of methods that an object can execute
      when it adopts the that protocol. </para>

    <para>To the Swarm user, the distinction between class and
      protocol is not vital most of the time.  The most important
      Swarm objects, such as the type Swarm (from
      <filename>objectbase/Swarm.h</filename>) or SwarmObject (from
      <filename>objectbase/SwarmObject.h</filename>), are classes from
      which users subclass to make model swarms or individual
      agents. It should not matter to the user that these classes have
      adopted protocols (taken on methods from protocol files inside
      the library).  The class SwarmObject, for example, adopts
      protocols Create and Drop. These protocols give SwarmObjects the
      ability to execute methods like createBegin, createEnd, or drop.
      Users who create classes using SwarmObject inherit these methods
      and there is no reason to be concerned whether SwarmObject got
      those methods by inheriting them from some other class or
      adoopting them from a protocol. </para>

    <para>The fact that many of the important components of the Swarm
      library are written as protocols can, however, be important in
      some notation. Early versions of Swarm, for example, had a class
      List from which users could subclass lists.  More recent
      versions have a List protocol.  This change causes a wrinkle
      that alters the syntax in user programs.  For example, when the
      ability to create lists was offered by a class, then the
      notation to create an instance of such a list would have been:

<programlisting>
List * listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

      In contrast, when the collections library is written as a
      protocol, the notation to define the type is different.  If one
      needs to define a variable listOfPuppies that is "statically
      typed" as a list, the command changes to:
      <programlisting>
id &lt; List &gt;  listOfPuppies;
listOfPuppies=[List create: [self getZone]];
      </programlisting>
    </para>

    <para>Since many of the important pieces of functionality in the
      Swarm library is now written in the protocol format, these
      details may be important. However, these details do not
      significantly change the way applications are designed.</para>

</sect2>
</sect1>

<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "SECT1")
End:
-->
