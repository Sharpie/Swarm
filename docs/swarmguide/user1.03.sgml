<sect1 id="swarm.user.user1.03.sect1">
  <title>Nuts and bolts of Objective-C</title>

  <para>Objective-C was created by Brad Cox. The aim was to create an
    elegant, object-oriented extension of C in the style of the
    Smalltalk language. (need reference here).  Objective-C was used
    most intensively in the design of the NeXT computer operating
    system, which is now owned by Apple and is basis of the Rhapsody
    OS.</para>

<sect2>
 <title>Why does Swarm use Objective-C?</title> 

 <para>Since C++ is more widely used than Objective-C, it is natural
      to ask why the Swarm project chose Objective-C. There are a
      number of reasons.

      <itemizedlist>
       <listitem>
          
          <formalpara><title>Objective C is easier to learn</title>
            <para>Objective-C takes the familiar C language and adds a
              few simple elements. Objective-C does not allow
              overloading or multiple inheritance of classes (although
              the use of protocols enables this, to an extent)</para>
          </formalpara>

        </listitem>

	<listitem>
          <formalpara><title>Objective C allows run-time binding</title> 

            <para>Objective-C leaves open the possibility that ???.
              At the time the Swarm project began, C++ did not allow
              this</para>
          </formalpara>
        </listitem> 
      </itemizedlist>

    </para>

</sect2>


<sect2>
 <title>The id variable type</title> 

    <para>The variable type that is added by Objective-C is
      <symbol>id</symbol>.  It is the default type for objects in
      Objective-C. Think of this as a special variable type (which is
      actually a pointer to a special data structure - namely the
      object)</para>

    <para>All objects can refer to themselves by using the label
      "self".  This is necessary if, in the code that defines the
      object, the programmer wants to make the object execute one of
      its methods.  For example, suppose an object has a method called
      "updateRecords".  If a command

        <programlisting>[self updateRecords];</programlisting>

      is received, then the updateRecords command will be executed,
      presumably to cause the updating of instance variables. </para>

    <para>All objects can refer to superclass by the name "super". For
      example,

<programlisting>[super updateRecords]</programlisting>

      </para>
</sect2>

<sect2>
 <title>Interface file: declaration of a class</title> 

    <para>If you look in a directory where some Swarm code resides,
      you will see files in pairs, such as ObserverSwarm.h and
      ObserverSwarm.m, ModelSwarm.h and ModelSwarm.m, and so forth.
      The "h" files are the interface files (commonly called "header
      files"), while the "m" files are the implementation files</para>

    <para>As illustrated in figure xxx (Benedikt "A few Objective-C
      basics), the interface declares the name of the class and the
      name of its superclass.  Then it gives a list of variable types
      and names enclosed by braces ({}), and then the names of the
      methods that the class can implement are listed. The variables
      defined in this list can be used by any of the methods defined
      for the class.  (These are often called "ivars", short for
      instance variables.)(Benedikt "Declaring a Class")</para>

  </sect2>

<sect2>
 <title>Implementation File: Defining a class</title> 

    <para>Each implementation file--the "m" that parallels the "h"--
      must import its header file.  If the header file is called
      Puppy.h, for example, the implementation look like</para>

    <programlisting>
#import "Puppy.h"
@implementation  Puppy
- (vartype)eatFood 
{
 (body)
 return returnval;
}
- playOutside: (vartype)arg 
{
 (body)
 return self;
}
</programlisting>

    <para>This example shows a number of important features.  First,
      note that the method "eatfood" specifies a return type,
      (vartype).  When that method is called, the receiving code must
      be able to accept a return of that type.  In contrast, the
      method "playOutside" does not specify a return type.  That means
      the default type, "id", is returned.  The code that calls this
      method must be consistent with that return type.</para>

    <para>The "return self" command is used for two types of
      situations.  Suppose the method is not intended to create any
      output, but rather it changes some instance variables. For
      example, suppose there is some program that creates an instance
      of Puppy called "spot". Then that object is sent this message:

<programlisting>[spot playOutside: theYard]
</programlisting>

      In such a case, the code that calls that method does not expect
      anything back from it.  Rather than fuss with (void) as the
      return type, as one might in C, one can simply include "return
      self".</para>

    <para>In another case, one might actually intend to return the
      object to a list or another object. In such a case, return self
      will also be appropriate. If one is making a list of puppies
      that have indeed played in the yard, for example, then the usage
      of "return self" in that method will give back spot's id to the
      calling program.</para>
</sect2>

<sect2>
 <title>C Functions vs. Objective-C methods </title> 

    <para>For readers who are already familiar with C, perhaps a
      comparison of C functions against Objective-C methods is in
      order.</para>

    <para>Objective-C method:</para>
    
<programlisting>
- (type)name: (type)arg1 argName2: (type)arg2 
{
 (body)
 return returnval;
}
</programlisting>

    <para>C function:</para>

    <programlisting>
(type)name((type) arg1,(type) arg2)) 
{
 (body)
 return returnval;
}
</programlisting>

    <para>Code in body could look exactly the same in C and
      Objective-C.  The two languages are compared side-by-side in
      figure (Benedikt "An example of C vs ObjC")</para>

</sect2>

<sect2><title>Giving life to classes: instantiation</title>

    <para>After the code is written for the interface and
      implementation, there is still work to be done. Instances of the
      class must be created. The creation of instances of a class is
      one of the specialized features of Swarm. Since the
      instantiation process is different from the that described in
      the Objective-C literature, it is worth some special
      attention.</para>

    <para>Object creation is often handeled in the model swarm, where
      specialized memory management and object creation code in the
      Swarm library is taken advantage of. The objects that represent
      the actors in a simulation--the substantively important
      entities--are usually subclassed from the Swarm class.  Because
      objects are subclassed from Swarm, that means they have access
      to all the methods that are defined for Swarm objects in the
      library.  The "inheritance hierarchy" that leads to the Swarm
      object starts with the superclass of all superclasses, Object,
      and subclasses from that through classes called
      "Object_s","Customize_s","CreateDrop_s","CSwarmProcess", and
      finally "Swarm".  Here is a list of all of these objects and
      their methods:

      <itemizedlist>
        <listitem><formalpara>
            <title>Object_s</title>
            <para></para>
          </formalpara></listitem>

	<listitem><para> - addRef:withArgument:</para></listitem>
        <listitem><para>+ alloc</para></listitem>
        <listitem><para>- compare:</para></listitem>
        <listitem><para>- copy</para></listitem>
        <listitem><para> - describe:</para></listitem>
        <listitem><para> - describeID:</para></listitem>
        <listitem><para> - drop</para></listitem>
        <listitem><para> - dropAllocations:</para></listitem>
        <listitem><para> - free</para></listitem>
        <listitem><para> - getClass</para></listitem>
        <listitem><para> + getClass</para></listitem>
        <listitem><para>+ getDefiningClass</para></listitem>
        <listitem><para> - getDisplayName</para></listitem>
        <listitem><para> - getIdName</para></listitem>
        <listitem><para> + getMethodFor:</para></listitem>
        <listitem><para>+ getName</para></listitem>
        <listitem><para>+ getNextPhase</para></listitem>
        <listitem><para> - getObjectName</para></listitem>
        <listitem><para> + getOwner</para></listitem>
        <listitem><para>+ getSuperclass</para></listitem>
        <listitem><para> - getType</para></listitem>
        <listitem><para> + getTypeImplemented</para></listitem>
        <listitem><para> - getZone</para></listitem>
        <listitem><para> + isSubclass:</para></listitem>
        <listitem><para> - perform:</para></listitem>
        <listitem><para> - perform:with:</para></listitem>
        <listitem><para> - perform:with:with:</para></listitem>
        <listitem><para> - perform:with:with:with:</para></listitem>
        <listitem><para> - removeRef:</para></listitem>
        <listitem><para> - respondsTo:</para></listitem>
        <listitem><para> + respondsTo:</para></listitem>
        <listitem><para> + self</para></listitem>
        <listitem><para> - setDisplayName:</para></listitem>
        <listitem><para> + setTypeImplemented:</para></listitem>
        <listitem><para> - shallowCopy</para></listitem>
        <listitem><para> - xfprint</para></listitem>
        <listitem><para>- xfprintid</para></listitem>
        <listitem><para>- xprint</para></listitem>
        <listitem><para> - xprintid</para></listitem>
        <listitem>
          <itemizedlist>
            <listitem><formalpara><title>Customize_s</title>
                <para></para>
              </formalpara></listitem>
            <listitem><para>- _setCreateByCopy_</para></listitem>
            <listitem><para>- _setCreateByMessage_:to:</para></listitem>
            <listitem><para>- _setCreateByMessage_:toCopy:</para></listitem>
            <listitem><para>- _setCreateBy_:message:to:</para></listitem>
            <listitem><para>- _setRecustomize_:</para></listitem>
            <listitem><para>+ customizeBegin:</para></listitem>
            <listitem><para>+ customizeBeginEnd:</para></listitem>
            <listitem><para>- customizeCopy:</para></listitem>
            <listitem><para>- customizeEnd</para></listitem>
            <listitem><para>+ setTypeImplemented:</para></listitem>
            <listitem>
              <itemizedlist>      
                <listitem><formalpara><title>CreateDrop_s</title><para></para></formalpara></listitem>
                <listitem><para>+ create:</para></listitem>
                <listitem><para>+ createBegin</para></listitem>
                <listitem><para>- createEnd</para></listitem>
                <listitem>
                  <itemizedlist> 
                    <listitem><formalpara><title>CSwarmProcess</title><para></para></formalpara></listitem>
                    <listitem><para>- _performPlan_</para></listitem>
                    <listitem><para>- activate</para></listitem>
                    <listitem><para>- activate:</para></listitem>
                    <listitem><para> - activateIn:</para></listitem>
                    <listitem><para>- at::activate:</para></listitem>
                    <listitem><para>- at:activate:</para></listitem>
                    <listitem><para>+ createBegin:</para></listitem>
                    <listitem><para>- createEnd</para></listitem>
                    <listitem><para>- getActivity</para></listitem>
                    <listitem><para>- getInternalTimeMultiplier</para></listitem>
                    <listitem><para>- getInternalZone</para></listitem>
                    <listitem><para>- getSwarmActivity</para></listitem>
                    <listitem><para>- mapAllocations:</para></listitem>
                    <listitem><para>- setInternalTimeMultiplier:</para></listitem>
                    <listitem><para>- setInternalZoneType:</para></listitem>
                    <listitem><para>- setSynchronizationType:</para></listitem>
                    <listitem><itemizedlist>
                        <listitem><formalpara><title>Swarm</title><para></para></formalpara></listitem>
                        <listitem><para>- activateIn:</para></listitem>
                        <listitem><para>- buildActions</para></listitem>
                        <listitem><para>- buildObjects</para></listitem>
                        <listitem><para> - getCompleteProbeMap</para></listitem>
                        <listitem><para>- getProbeForVariable:</para></listitem>
                        <listitem><para> - getProbeMap</para></listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
</para>

    <para>The long list of features here is included to emphasize the
    point that programs that subclass from Swarm inherit a great deal
    of power.</para>

    <para>In Swarm models, objects are often created by a pair of
      "bookend" commands, createBegin and createEnd. This is not part
      of the Objective-C syntax.  Rather, it is unique to
      Swarm. </para> 

    <para>Suppose the Puppy.h and Puppy.m files exist, and one wants
      to create an instance of that class.  In a file ModelSwarm.m,
      one would typically have a method called "buildObjects", which
      is usually a method that houses all object creation. For
      example:

<programlisting>
//Excerpt from ModelSwarm.m that creates a puppy instance
     #import "Puppy.h"
     {other imports and code that defines agents, schedules, etc}
-buildObjects {    
       Puppy * puppy;
       puppy = [Puppy createBegin: [self getZone]];
       {commands that set permanent features of the puppy can apppear here}
       puppy = [puppy createEnd];
}
</programlisting>

      The class's "factory object", Puppy, is told to create an object
      in a memory zone that is provided by ModelSwarm (ModelSwarm is
      the "self" in [self getZone]). Then the object "puppy" is
      instructed to finish the creation process, after optional
      commands are added to define the features of the object
      (typically, to set values of the object's instance
      variables). Many of these subtleties are explained in depth in
      later sections.</para>

    <para>Not all object instances are created by the
      createBegin/createEnd pair. Some of the built-in objects can be
      created by a simple create command.  For example, the Swarm
      collections library includes a class called "List".  If one
      needs to create an object from that class, a command like this
      will work in ModelSwarm.m:

<programlisting>
id listOfPuppies;
listOfPuppies=[List create: [self getZone]];

</programlisting>
    </para>

</sect2>

<sect2><title>A brief clarification: Classes versus Protocols</title>

    <para>There is one additional complication that readers should be
      aware of.  Objective-C allows the creation of objects by
      subclassing from protocols as well as classes.  A protocol, as
      readers will recall from their study of Objective-C, is a set of
      methods that an object can execute when it is subclassed from
      that protocol. </para>

    <para>To the user, it often makes little difference whether
      <filename>Swarm.h</filename> refers to a class or a protocol
      because the methods are available, just the same. In version 1
      of Swarm, many of the library entities were written as classes.
      More recent versions have been redesigned so that the major
      libraries are written as protocols.  This changeover has some
      implications for notation and terminology, but at the user-level
      these are easily accommodated.  Here is one example of the
      difference. When the ability to create lists was offered by a
      class, then the notation to create an instance of such a list
      would have been:

<programlisting>
List * listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

      In contrast, when the collections library is written as a
      protocol, the notation to define the type is different.  If one
      needs to define a variable listOfPuppies that is "statically
      typed" as a list, the command changes to:
      <programlisting>
id &lt; List &gt;  listOfPuppies;
listOfPuppies=[List create: [self getZone]];
      </programlisting>
    </para>

    <para>Since the Swarm library is now written in the protocol
      format, these slight wrinkles arise, but they do not
      significantly change the way applications are designed.</para>

</sect2>
</sect1>

<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "SECT1")
End:
-->
