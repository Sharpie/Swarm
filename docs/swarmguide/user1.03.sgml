<chapter id="swarm.user.user1.03.chapter">
  <title>Nuts and bolts of Objective-C</title>

  <para>Objective-C was created by Brad Cox. The aim was to create an
    elegant, object-oriented extension of C in the style of the
    Smalltalk language. (need reference here).  Objective-C was used
    most intensively in the design of the NeXT computer operating
    system, which is now owned by Apple and is basis of Apple's
    runtime environment WebObjects.</para>

<sect1 id="swarm.user.user1.03-objc-why.sect1">
 <title>Why does Swarm use Objective-C?</title> 

 <para>Since C++ is more widely used than Objective-C, it is natural
      to ask why the Swarm project chose Objective-C. There are a
      number of reasons:

      <itemizedlist>
       <listitem>
          
          <formalpara><title>Objective C is easier to learn</title>
            <para>Objective-C takes the familiar C language and adds a
              few simple elements. Objective-C does not allow
              overloading or multiple inheritance of classes (although
              the use of protocols enables this, to an extent)</para>
          </formalpara>

        </listitem>

	<listitem>
          <formalpara><title>Objective C allows run-time binding</title> 

            <para>Run-time binding is somewhat esoteric and
            controversial.  In contrast to other languages which check
            the match between the receiver of a command and its
            ability to carry out the command when a program is
            compiled, Objective-C leaves that matching exercise until
            the program is running.  This means, for example, that one
            can have a program that builds a list of objects and then
            sends a message to each one.  In Objective-C, the compiler
            won't worry about which type of object is in the list. The
            advantage, conceptually, is that one can put commands in
            their code without knowing the precise identity of the
            receiver, so code can be written to allow an environment
            and set of objects to change and evolve. The disadvantage,
            as critics of run-time binding will quickly point out, is
            that programs crash when an object recieves a message and
            it does not have the method that it is being told to
            execute.  The organization of Swarm into protocols reduces
            the risk of these crashes, however, because the compiler
            does check and issue a warning if a method is not
            implemented in a class that advertises a certain
            protocol.</para>
          </formalpara>
        </listitem> 
      </itemizedlist>

    </para>

</sect1>


  <sect1 id="swarm.user.user1.03-objc-id.sect1">
    <title>The <type>id</type> Variable Type</title>

    <para>The variable type that is added by Objective-C is
      <type>id</type>.  It is the default type for objects in
      Objective-C. Think of this as a special variable type (which is
      actually a pointer to a special data structure - namely the
      object)</para>

    <para>All objects can refer to themselves by using the label
      <varname>self</varname>.  This is necessary if, in the code that
      defines the object, the programmer wants to make the object
      execute one of its methods.  For example, suppose an object has
      a method called <function>updateRecords</function>.  If a
      command</para>

    <programlisting role="ObjC">[self updateRecords];</programlisting>

    <para> is received, then the <function>updateRecords</function>
      command will be executed, presumably to cause the updating of
      instance variables. </para>
    
    <para>All objects can refer to superclass by the name
      <varname>super</varname>. For example:</para>

    <programlisting role="ObjC">[super updateRecords]</programlisting>

  </sect1>
  
  <sect1 id="swarm.user.user1.03-objc-interface.sect1">
    <title>Interface File: Declaration of a Class</title> 
    
    <para>If you look in a directory where some Swarm code resides,
      you will see files in pairs, such as
      <filename>ObserverSwarm.h</filename> and
      <filename>ObserverSwarm.m</filename>, ModelSwarm.h and
      <filename>ModelSwarm.m</filename>, and so forth.  The "h" files
      are the interface files (commonly called "header files"), while
      the "m" files are the implementation files</para>

    <figure id="objc-basics.figure">
      <title>Objective C Basics</title>
      <graphic entityref="objc-basics"></graphic>
    </figure>

    <para>As illustrated in <xref linkend="objc-basics.figure">, the
      interface declares the name of the class and the name of its
      superclass.  Then it gives a list of variable types and names
      enclosed by braces ({}), and then the names of the methods that
      the class can implement are listed. The variables defined in
      this list can be used by any of the methods defined for the
      class.  (These are often called "ivars", short for instance
      variables.)
    <example id="swarm.user.user1.03.objc-class.example">
      <title>Objective C class</title>

      <programlistingco>
          <areaspec>
            <area coords="1 1" id="decl">
            <area coords="1 12" id="subclass">
            <area coords="1 18" id="superclass">
            <area coords="3 30" id="instance">
            <area coords="6 29" id="method1">          
            <area coords="7 8" id="method2">
          </areaspec>

<programlisting role="ObjC">
@interface Bug : SwarmObject {
  int xPos, yPos;
  int worldXSize, worldYSize;
  id foodSpace;
}
- setX: (int) x Y: (int) y;
- step;

@end</programlisting>
          
          <calloutlist>
            <callout arearefs="decl">
              <para>Declarations of instance variables and methods</para>
            </callout>
            <callout arearefs="subclass">
              <para>Sub class</para>
            </callout>
            <callout arearefs="superclass">
              <para>Super class</para>
            </callout>
            <callout arearefs="instance">
              <para>Instance Variables</para>
            </callout>
            <callout arearefs="method1">
              <para>declares method called <function>set</function> 
                that takes two arguments</para>
            </callout>
            <callout arearefs="method2">
            <para>declares a method called <function>step</function>.</para>
            </callout>

          </calloutlist>
        </programlistingco>
      </example>

    </para>

  </sect1>

<sect1 id="swarm.user.user1.03-objc-impl.sect1">
 <title>Implementation File: Defining a Class</title> 

    <para>Each implementation file--the "m" that parallels the "h"--
      must import its header file.  If the header file is called
      <filename>Puppy.h</filename>, for example, the implementation
      looks like:</para>

    <programlisting role="ObjC">
#import "Puppy.h"
@implementation  Puppy
- (vartype)eatFood 
{
 (body)
 return returnval;
}
- playOutside: (vartype)arg 
{
 (body)
 return self;
}</programlisting>

    <para>This example shows a number of important features.  First,
      note that the method <function>eatfood</function> specifies a
      return type, (<replaceable>vartype</replaceable>). In this
      example, <replaceable>vartype</replaceable> would have to be
      replaced by a variable type, such as <type>int</type>,
      <type>float</type>, or whatever, and
      <replaceable>returnval</replaceable> would have to be a variable
      of that type.  When that method is called, the receiving code
      must be able to accept a return of that type.  In contrast, the
      method <function>playOutside</function> does not specify a
      return type.  That means the default type, <type>id</type>, is
      returned.  The code that calls this method must be consistent
      with that return type.</para>

    <para>The <literal>return self</literal> command is used for two
      types of situations.  Suppose the method is not intended to
      create any output, but rather it changes some instance
      variables. For example, suppose there is some program that
      creates an instance of <classname>Puppy</classname> called
      <varname>spot</varname>. Then that object is sent this message:</para>

<programlisting role="ObjC">[spot playOutside: theYard]</programlisting>

    <para>In such a case, the code that calls that method does not
      expect anything back from it (except itself).  Rather than fuss
      with <type>void</type> as the return type, as one might in C,
      one can simply return <varname>self</varname>.</para>

    <para>In another case, one might actually intend to return the
      object to a list or another object. In such a case, return self
      will also be appropriate. If one is making a list of puppies
      that have indeed played in the yard, for example, then the usage
      of <literal>return self</literal> in that method will give back
      spot's <type>id</type> to the calling program. To be perfectly
      concrete about it, suppose the calling code has a list called
      <function>dogsPlayed</function>.  Then using the
      <function>addLast</function> notation from the Swarm collections
      library, the command to add spot to the list after playing
      outside might look like this:</para>

    <programlisting role="ObjC">[dogsPlayed addLast: [spot playOutside: theYard]];
    </programlisting>
  </sect1>
  
  <sect1 id="swarm.user.user1.03-objc-c.sect1">
    <title>C Functions vs. Objective-C Methods </title> 
    
    <para>For readers who are already familiar with C, perhaps a
      comparison of C functions against Objective-C methods is in
      order. Since Objective-C is a superset of C, an Objective-C
      method can include any valid C commands. A method can return any
      type that a C function can return, and in addition it can an id
      (which, strictly speaking, is a pointer to an object).  </para>

    <para>In the abstract, an Objective-C method has this structure:</para>
    
<programlisting role="ObjC">
- (type)name: (type)arg1 argName2: (type)arg2 
{
 (body)
 return returnval;
}</programlisting>

    <para>In comparison, a C function would look like this:</para>

    <programlisting role="C">
(type)name((type) arg1,(type) arg2)) 
{
 (body)
 return returnval;
}</programlisting>

    <para>The code in body of an Objective-C method can be exactly the
    same as in C.  The two languages are compared side-by-side in the
    following example, which describes how a function
    <function>rand_move()</function> might compare to a method
    <function>rand_move:</function>.  Of course, each of these assumes
    there are other functions and variables that can be accessed, but
    the contrast in style should be informative.
    
      <example id="swarm.user.user1.03.c-vs-objc.example">
        <title>C vs Objective-C</title>

        <programlisting role="C">
void rand_move(int i) {    

 int tmp_loc;

 do{
 tmp_loc=get_rand_loc();
 } while(val[tmp_loc]!=0);

 val[location[i]]=0;
 val[tmp_loc]=i;
}</programlisting>

    <programlisting role="ObjC">
- rand_move: p 
{
  id loc;

  do{
   loc=[self getRandLoc];

  } while([world at: loc]!=nil);

 [p moveTo: loc];
 return self;
}</programlisting>

      </example>
    </para>

</sect1>

  <sect1 id="swarm.user.user1.03-objc-inst.sect1">
    <title>Giving Life to Classes: Instantiation</title>
    
    <para>After the code is written for the interface and
      implementation, there is still work to be done. Instances of the
      class must be created. The creation of instances of a class is
      one of the specialized features of Swarm. Since the
      instantiation process is different from the that described in
      the Objective C literature, it is worth some special
      attention.</para>

    <para>The creation of the substantively important objects is often
      handeled in the model swarm.  This process uses the specialized
      memory management and object creation code in the Swarm
      library.</para>

    <para>The objects that represent the actors in a simulation--the
      substantively important entities--are usually subclassed from
      the <classname>SwarmObject</classname> class. The "inheritance
      hierarchy" that leads to the class
      <classname>SwarmObject</classname> passes through classes that
      allow the creation and deletion of objects from a simulation.
      Objects are often created by a pair of "bookend" commands,
      <function>createBegin</function> and
      <function>createEnd</function>. This is not part of the
      Objective C syntax.  Rather, it is unique to Swarm. </para>

    <para>Suppose the <filename>Puppy.h</filename> and
      <filename>Puppy.m</filename> files exist, and one wants to
      create an instance of that class.  In a file
      <filename>ModelSwarm.m</filename>, one would typically have a
      method called <function>buildObjects</function>, which is
      usually a method that houses all object creation. For example:</para>
    
<programlisting role="ObjC">
//Excerpt from ModelSwarm.m that creates a puppy instance
#import "Puppy.h"
// {other imports and code that defines agents, schedules, etc}
- buildObjects 
{    
    Puppy * puppy;
    puppy = [Puppy createBegin: self ];
    {commands that set permanent features of the puppy can apppear here}
    puppy = [puppy createEnd];
}</programlisting>

    <para> The class's "factory object", <classname>Puppy</classname>,
      is told to create an object in a memory zone that is provided by
      <classname>ModelSwarm</classname>
      (<classname>ModelSwarm</classname> is the
      <varname>self</varname>.). Then the object
      <varname>puppy</varname> is instructed to finish the creation
      process, after optional commands are added to define the
      features of the object (typically, to set values of the object's
      instance variables). Many of these subtleties are explained in
      depth in later sections.</para>

    <para>Not all object instances are created by the
      <function>createBegin</function>/<function>createEnd</function>
      pair. Some of the built-in objects can be created by a simple
      create command.  For example, the Swarm collections library
      includes a class called <classname>List</classname>.  If one
      needs to create an object from that class, a command like this
      will work in <filename>ModelSwarm.m</filename>:</para>

<programlisting role="ObjC">
id listOfPuppies;
listOfPuppies=[List create: self];</programlisting>

     <para>In code written for older versions of the Swarm toolkit,
      one will often see a slightly different syntax in
      <filename>ModelSwarm.m</filename>:</para>

<programlisting role="ObjC">
id listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

    <para>This usage is still valid, although it is deprecated.  Since
      now the objects of type <classname>Swarm</classname>, like the
      model swarm itself, are memory zones, there is no need to get a
      zone in which to put the list.  Rather, the list can be put in
      the zone that is provided by the model swarm itself.
    </para>

</sect1>

<sect1 id="swarm.user.user1.03-classes.sect1">
    <title>A Brief Clarification: Classes and Protocols</title>

    <para>There is one additional complication that readers should be
      aware of.  Objective-C allows the creation of entities called
      protocols.  A protocol, as readers will recall from their study
      of Objective-C, is a list of methods that an object is able to
      execute.  Swarm is structured by protocols, which means that
      there are lists of methods assigned to various names and classes
      inside the library "adopt" those protocols and then implement
      the methods listed in the protocols.  Hence, in the Swarm
      Reference materials present the libraries as a collection of
      classes, each of which adheres to a given set of
      protocols. </para>

    <para>To the Swarm user, the distinction between class and
      protocol is not vital most of the time.  The most important
      Swarm protocols, such as the type <classname>Swarm</classname>
      (from <filename>objectbase/Swarm.h</filename>) or
      <classname>SwarmObject</classname> (from
      <filename>objectbase/SwarmObject.h</filename>), can be used as
      if they were classes.  In the Swarm Reference Guide, there is a
      list of all protocols.  The protocols that adopt the
      <classname>CREATABLE</classname> protcol are the ones that users
      can use as if they were factory objects.  For example, the
      <classname>EZGraph</classname> protocol adopts the
      CREATABLE protocol, so when the user needs to create an
      instance, so the observer swarm file can use the EZGraph to
      create graphs.</para>  

    <para> Almost all of the Swarm protocols adopt the CREATABLE
      protocol, so they can be used as if they were classes from
      which users subclass to make model swarms or individual
      agents.  It should not matter to the user that these are
      abstract defined types that have
      adopted protocols (taken on the obligation to implement methods
      listed in protocols).  The class
      <classname>SwarmObject</classname>, for example, adopts
      protocols <classname>Create</classname> and
      <classname>Drop</classname> as well as CREATABLE. This means
      that the user can act as if there is a class called
      <classname>SwarmObject</classname>, and that the SwarmObject
      will be able to respond to class methods like
      <function>createBegin</function>, and that instances created by
      SwarmObject will be able to respond to 
      <function>createEnd</function>, <function>drop</function>, or
      any other method that is listed in a protocol listed by SwarmObject.</para>
      
    <para> One of the principal advantages of protocol usage is that
      there will be compile-time warnings if the user's code tries to
      send a "bad message" to an object.  If a message tells an object
      to <function>goOutside</function>, and none of the protocols
      adopted by that agent have a method called
      <function>goOutside</function>, then the compiler will warn the
      user about it.  In a crude way, adopting a protocol is like
      advertising that a class can do certain things, and the compiler
      enforces a `truth in advertising' policy. If the compiler flags
      include -WERROR, causing all warnings to be treated as errors,
      then these warnings will stop the compilation.</para>

    <para>The fact that many of the important components of the Swarm
      library are organized as protocols can, however, be important in
      some notation. Early versions of Swarm had less emphasis on
      protocols than the current version.  As a result of the
      introduction of protocols, usage conventions have changed.  In
      Swarm, there is a class <classname>List</classname> that can be
      used to create collections.  In the "old days" of Swarm, one
      would create a statically typed object of class
      <classname>List</classname>, as this code indicates:</para>


<programlisting role="ObjC">
List * listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

    <para>Swarm no longer allows users to statically allocate objects
    in this way.  This code will make the compiler crash, because
    there is no class inside Swarm called List, there is only a
    protocol. The compiler will fail, and the user will get a vague
    warning about a parse error in the vicinity of the List usage. </para>

    <para>We know from the Swarm Reference Guide that the <classname>List</classname> protocol
      advertises that it adopts the <classname>CREATABLE</classname>
      protocol, so the mistake is not in the usage of List to
      create the listOfPuppies.  Rather, the mistake is in the
      declaration of the listOfPuppies itself.  If one
      needs to define a variable <varname>listOfPuppies</varname> that
      has the properties of a <classname>List</classname> class item,
      the recommended approach is to create a variable of type
      <type>id</type> and indicate the protocols adopted by that
      object in brackets:</para>

    <programlisting role="ObjC">
id &lt; List &gt;  listOfPuppies;
listOfPuppies=[List create: [self getZone]];
      </programlisting>

    <para>It is also legal to define listOfPuppies as a generic
    object, as in </para>
<programlisting role="ObjC">
id listOfPuppies;
listOfPuppies=[List create: [self getZone]];
</programlisting>

    <para>This usage is legal, and the program should compile without
    difficulty.  The only shortcoming is that the user will not be
    warned if the listOfPuppies object is sent any inappropriate
    messages within the program.  When these inappropriate messages
    are sent during the run, then the program will crash, possibly
    with a message that the object listOfPuppies does not respond to
    the message it was sent. </para>

    <para>Since almost all of the important pieces of functionality in
      the Swarm library are now written in the protocol format and are
      CREATABLE, these details may be important. However, these
      details do not significantly change the way applications are
      designed.  Swarm entities can still be treated as classes.</para>

</sect1>
</chapter>

<!--
Local Variables:
sgml-parent-document:("userbook.sgml" "CHAPTER")
End:
-->
