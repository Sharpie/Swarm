<sect1 id="swarm.user.user3.05.sect1">
  <title>Serialization</title>

  <indexterm>
    <primary>serialization</primary>
  </indexterm>

  <para>The term <wordasword>serialization</wordasword> refers to the
    ability to save more than one related object to either persistent data
    storage (such as a file) or to send an object over a network stream,
    such as TCP/IP.  When an object is saved to disk (or sent over a
    `wire') we record a reference to the saved object, so that the
    original object can be restored at a later date.  This reference is
    referred to as a `serial number', hence the term `serialization'.
  </para>

  <para>Swarm has two forms of support for serialization:

    <itemizedlist>
      <listitem>
        <indexterm significance="preferred">
          <primary>Lisp</primary>
        </indexterm>
        <formalpara><title>Lisp</title><para>Lisp
            serialization reads and generates human readable text-file
            in Lisp format.  This form of serialization is well-suited
            to applications that require either a human generated text
            file to create object parameters (such as simulation
            parameter files), or require a human-readable
            output.</para></formalpara>
      </listitem>

      <listitem>
        <indexterm significance="preferred">
          <primary>HDF5</primary>
        </indexterm>
        <formalpara><title>HDF5</title><para><ulink
            url="http://hdf.ncsa.uiuc.edu/HDF5/">HDF5</ulink> is high
            density binary data storage format created by <ulink
            url="http://www.ncsa.uiuc.edu/">NSCA</ulink>.  HDF5
            serialization is well-suited to applications that involve
            reading and/or saving large data sets.  It is a
            database-oriented format which a number of third-party
            tools (such as the <application><ulink
            url="http://www.ci.tuwien.ac.at/R/">R</ulink></application>
            statistical package which is a freely-available clone of
            <application><ulink
            url="http://www.mathsoft.com/splus/">SPlus</ulink></application>)
            can read.</para></formalpara>
      </listitem>
    </itemizedlist>
  </para>

  <sect2>
    <title>Using the Lisp <classname>Archiver</classname> to manage
      simulation parameters</title>
    <indexterm>
      <primary>parameter files</primary>
    </indexterm>
    <caution><para>Earlier versions of Swarm used the protocols
        <classname>ObjectSaver</classname> and
        <classname>ObjectLoader</classname> to read/write object state to disk
        using an ad-hoc file format.  These protocols only partially
        implemented the saving of certain types and the continued use of these
        protocols is now officially deprecated and may go away in future
        releases.</para></caution>

    <sect3>
      <title>Using the standard <varname>lispAppArchiver</varname></title>
      <indexterm significance="preferred">
        <primary><classname>Archiver</classname></primary>
        <secondary>application</secondary>
        <tertiary>global</tertiary>
      </indexterm>
      <para>Every Swarm application comes with a singleton
        <footnote>
          <para>A singleton class is a class that is designed to have
            only one global instance per application</para>
        </footnote>
        instance variable for reading object data formatted in Lisp.
        This instance is called <varname>lispAppArchiver</varname>.
        Like the <varname>probeLibrary</varname> and
        <varname>arguments</varname> instances, it is global to your
        entire application.  This instance expects to find a file
        called
        <filename><application>appName</application>.scm</filename>
        <footnote><para><filename>.scm</filename> is the standard
        suffix for Scheme (a dialect of Lisp) files</para></footnote>:
        , in either the current datapath for the application
        (<filename>
          <envar>
            SWARMHOME</envar>/share/swarm/<application>appName</application>
        </filename>) or in the local directory.  Using this variable
        obviates the need for hand creation of
        <classname>Archiver</classname> instances.  It permits one
        datafile (which can contain as many keys to objects as is
        required), and imposes a naming convention for that datafile.
     </para>

    </sect3>

    <sect3>
      <title>Using a custom <classname>Archiver</classname> instances</title>
      <indexterm>
        <primary><classname>Archiver</classname></primary>
        <secondary>application</secondary>
        <tertiary>custom</tertiary>
      </indexterm>
      <para>This sections addreses those situations that require
      custom creation of multiple data files, and alternate data
      filenames.</para>

    <example>
      <title>Creating a Lisp parameter file</title>

        <para>Here is a sample Lisp input parameter for the
          <application>Mousetrap</application> simulation,
          <filename>batch.scm</filename>
        </para>

        <programlisting>
(list
 (cons 'batchSwarm
       (make-instance 'MousetrapBatchSwarm  ; parameters for the batchSwarm
                      #:loggingFrequency 1))
 (cons 'modelSwarm
       (make-instance 'MousetrapModelSwarm  ; parameters for the modelSwarm
                      #:gridSize 40
                      #:triggerLikelihood 1.0
                      #:numberOutputTriggers 4
                      #:maxTriggerDistance 4
                      #:maxTriggerTime 16
                      #:trapDensity 1.0)))</programlisting>

        <para>The Lisp file consists of two `keys' or `serial' numbers
          <literal>batchSwarm</literal> and
          <literal>modelSwarm</literal> for the parameters for two
          different objects.  These keys are completely at the
          discretion of the user to choose.  (Note also that the file
          syntax allows Lisp-style comments: a `;' colon followed by
          any text).</para>

        <para>This input file would correspond with the following
          interface files, for the
          <classname>MousetrapBatchSwarm</classname> class we
          have:</para>

        <programlisting>
<![ CDATA [
[...]
#import "MousetrapModelSwarm.h"

@interface MousetrapBatchSwarm: Swarm
{
  int loggingFrequency;		       		 // Frequency of fileI/O

  id displayActions;				 // schedule data structs
  id displaySchedule;

  MousetrapModelSwarm * mousetrapModelSwarm;	 // the Swarm we're observing

                                                 // The EZGraph will be used 
  id triggerGraph;                               // in FileI/O mode rather 
                                                 // than the usual Graphics 
                                                 // mode...
}
// methods not shown
@end]]></programlisting>
        
      <para>For the <classname>MousetrapModelSwarm</classname> class:</para>

        <programlisting>
<![ CDATA [
[...]
#import "Mousetrap.h"
@interface MousetrapModelSwarm: Swarm
{
  int gridSize;					  // simulation parameters
  double triggerLikelihood;
  int numberOutputTriggers;
  int maxTriggerDistance;
  int maxTriggerTime;
  double trapDensity;

  id modelActions;				  // scheduling data structures
  id modelSchedule;

  MousetrapStatistics *stats;			  // statistics object
  id <Grid2d> grid;				  // world

  // Declare the ActivityControl, which will serve as an interface to
  //   the model swarm activity.
  id <ActivityControl> modelActCont;

@private
  id <PMMLCG1> randomGenerator;
  id <UniformDouble> uniform0to1;
}

// Methods not shown
@end]]></programlisting>

      <para>Note that for each instance variable name of the form
        <literal>#:ivarname somevalue</literal> in the Lisp parameter
        file there exists a corresponding instance variable in the
        class header file. <emphasis>However, not</emphasis> all
        instance variables in the header file have corresponding
        entries in the Lisp parameter file.  This is because the other
        instance variables are either unimportant as parameters
        (i.e. they can be regenerated by other parameters), or they
        are instance variables that pertain to the running model
        itself (such as <varname>modelSchedule</varname>, which is a
        <classname>Schedule</classname> instance).</para>

      <para>To generate the objects with these corresponding
        parameters set in each object, you need to create an instance
        of the <classname>Archiver</classname> ask the archiver to
        `generate' an instance of the object using the appropriate
        `key'.  So here's an excerpt from <filename>main.m</filename>:</para>

<programlisting>
  if (swarmGUIMode == 1)
    {
      // Do GUI mode creation (ommited)
    }
  else
    // No graphics - make a batchmode swarm and run it.
    {
      // create an instance of the Archiver to retrieve the file
      // set the path to `batch.scm'
      id archiver =  [[[[Archiver createBegin: globalZone]
                         setHDF5Flag: NO]
                        setPath: "batch.scm"]
                       createEnd];  

      // retrieve the object from the archiver, if it can't be found
      // just raise an event; note that the call to the
      // archiver will actually *instantiate* the object if the
      // parameters are found in the Lisp file
      if ((theTopLevelSwarm = 
           [archiver getObject: "batchSwarm"]) == nil)    
        raiseEvent(InvalidOperation, 
               "Can't find archiver file or appropriate key");
    }</programlisting>

      <para>The key thing to realize here is that the
      <function>getObject</function> call actually
      <emphasis>instantiates</emphasis> the object (i.e. automatically
      runs the
      <function>createBegin</function>/<function>createEnd</function>
      apparatus internally<footnote> <para>Note that this is in
      contrast to the obsolete <classname>ObjectLoader</classname>
      method, which required the user to create the object and then
      make a call to an <classname>ObjectLoader</classname> instance
      with the appropriate filename.</para></footnote>). This has
      implications for the design of parameter files, since it means,
      for one thing, that all the appropriate instance variables
      necessary for a complete creation of an object
      <emphasis>must</emphasis> be present in the input Lisp file.  It
      is possible to have a subset of ivars, but that subset should be
      sufficient to completely specify the object, i.e. no CREATE time
      messages can be sent to the object once it has been created.
      (Of course you can still send SETTING or USING messages to
      instance once it has been created).
      </para>

      <para>The <classname>MousetrapModelSwarm</classname> is created
        in a similar way, from the <function>buildObjects</function>
        method in <filename>MousetrapBatchSwarm.m</filename>:</para>

<programlisting>
  // * `modelSwarm' is the key for the instance of the MousetrapModelSwarm
  //   with parameter values for the model instance variables: gridSize
  //   triggerLikelihood, numberOutputTriggers, maxTriggerDistance, 
  //   maxTriggerTime, trapDensity  

  // if we can't find the right key from the Archiver, raise an event
  if ((mousetrapModelSwarm = 
       [archiver getObject: "modelSwarm"]) == nil)
    raiseEvent(InvalidOperation, 
               "Can't find archiver file or appropriate key");
  
  // Now, let the model swarm build its objects.

  [mousetrapModelSwarm buildObjects];</programlisting>

        <para>Note that <emphasis>after</emphasis> the creation of the
        <varname>mousetrapModelSwarm</varname> instance, it responds
        in the normal way to valid methods, such as
        <function>buildObjects</function>.
      </para>

    </example>
    </sect3>

  </sect2>

</sect1>

<!-- 
Local Variables: 
sgml-parent-document:("userbook.sgml" "SECT1")
End: 
-->
