<sect1 id="swarm.user.user2.06.sect1">
  <title>Checking on a Swarm's progress: The Observer</title>

  <sect2>
    <title>As They Say in Tommy, "See Me, Feel Me..."  <comment>Not a
      big Who fan... ;-) Can we think of a better title?  - AKL
      1999-05-06</comment> </title>

    <para> When a Swarm program is running in the GUI mode, what the
      user sees is controlled by the top level Swarm that we often
      call the observer swarm.  The observer swarm adopts the
      <classname>GUISwarm</classname> protocol, which means that it
      has all of the features of a Swarm plus some "optional added
      extras."  The file that contains the source that controlls the
      user interface for a specific project may be called simply
      <filename>ObserverSwarm.m</filename>.  In many examples, authors
      have customized the name of the file to include the name of
      their project, as in <filename>HeatbugObserverSwarm.m</filename>
      or <filename>ForestModelSwarm.m</filename>
    </para>

    <para>
      The most prominent of the extra features of the observer swarm
      is the control panel.  The control panel is the familiar set of
      buttons that can <guibutton>start</guibutton> and
      <guibutton>stop</guibutton> a swarm model.  The control panel
      also can "step" the simulation through its paces one time-unit
      at-at-time using the <guibutton>next</guibutton> button.  The
      <guibutton>save</guibutton> button on the control panel is
      intended to save the window positions of objects that are able
      to do so.
    </para>

    <para>
      Apart from the control panel, what the user sees at run-time is
      completely dependent on the particular example that is being
      considered.  It is probably safe to say, however, that if one
      stays within the Swarm library, without adding external support
      from the Graph library or other toolkits, then there two
      especially important kinds of display objects that can be
      created in <filename>ObserverSwarm.m</filename>. These two are:

      <itemizedlist>
        <listitem>
          <formalpara><title>The <classname>ZoomRaster</classname></title>

            <para>In just about any of the common swarm applications,
              there is some sense of geometry or spatial position. The
              <classname>ZoomRaster</classname> graph is the tool that
              is used to represent the positioning of agents and other
              objects in that space.
            </para>

          </formalpara>
        </listitem>

        <listitem>

          <formalpara>
            <title>The Data Display Graphs <comment>This is a title I just
              made up to refer to <classname>EZGraphs</classname> and 
              <classname>EZDistribution</classname>
              protocols--pj,1999-04-16</comment> </title>
            
            <para>For the visual presentation of summary information,
              Swarm provides a set of tools for presenting information
              in graphic format.  Two of the most common sorts are the
              histogram, which shows the relative frequency of various
              values occuring in a stream of data, and a line graph
              which displays the changes over time in one or more
              variables as a simulation progresses.  These
              capabilities are provided by the Swarm protocols
              <classname>EZDistribution</classname> and
              <classname>EZGraph</classname>, respectively.
            </para>
          </formalpara>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      The following sections discuss the achitecture of these two
      classes of displays in greater depth. Most of the examples for
      discussion are taken from the <application>Arborgames</application> code provided by
      Melissa Savage.
    </para>
  </sect2>

  <sect2>
    <title>Making a clickable <classname>ZoomRaster</classname></title>

    <para>
      There is no doubt that one of the most impressive aspects of a
      Swarm presentation is the visually intriguing movement of agents
      on a landscape.  The ability to stop a simulation from the
      control panel and then click on objects, open up displays that
      reveal their internal variables and allow them to be changed, is
      one of the main strengths of the Swarm library.
    </para>

    <para>
      In order to introduce the way in which these
      <classname>ZoomRaster</classname> displays are created, we have
      to introduce a number of inter-linked Swarm toolkit items.
      Before we are done, we have to talk about objects created using
      the Space library, as well as objects from the Gui library.  In
      the <application>Arborgames</application> simulation, there is a
      set of standard examples that quite nicely illustrate the vital
      steps.  For emphasis, we now consider these elements
      individually.

      <orderedlist>

        <listitem>
          <formalpara>
            <title>Create a <classname>ColorMap</classname></title>

            <para>Swarm was first developed for the Unix operating
              system. Programmers who have worked in X will probably
              already know that the X server offers a long list of
              possible colors.  If we want to access those colors, we
              can build a <classname>ColorMap</classname> object in
              Swarm.  After it is defined, and commands are executed
              which draw on the screen, then the
              <classname>ColorMap</classname> object will control
              which colors are displayed.
            </para>
          </formalpara>

          <para>Here is an excerpt from the file
            <filename>ForestObserverSwarm.m</filename> in which an
            object, called <varname>colormap</varname>, is created and
            then told to remember that the numbers 25, 26,and 27 refer
            to the colors "white","LightCyan1" and "PaleTurquoise"
            which is defined deep in the bowels of the video display.

            <programlisting>
              colormap = [Colormap create: [self getZone]];

              [colormap setColor: 25 ToName: "white"];
              [colormap setColor: 26 ToName: "LightCyan1"];
              [colormap setColor: 27 ToName: "PaleTurquoise"];
            </programlisting>
          </para>

          <para>

            <classname>ColorMap</classname>s can have fancier
            items. For example, colors need not be referred to by
            simple names. Rather, each color can be referred to in a
            numerical format. All colors can be referred to by the
            intensity of their red, blue, and green components, for
            example.  If one needs to assign the many available shades
            of red to the numbers between 100 and 150, it can easily
            be done with commands that use the RGB format.  There is
            an example of such a use of the
            <classname>ColorMap</classname> protocol in the
            <application>heatbugs</application> source code.
          </para>
        </listitem>

        <listitem>          
          <formalpara>
            <title>Create a <classname>ZoomRaster</classname></title>

            <para>
              A <classname>ZoomRaster</classname> is a visual
              placeholder, a rectangular entity of a certain size.
              After trimming out some of the detail, the steps that
              create the <classname>ZoomRaster</classname> called
              <varname>forestRaster</varname> in
              <application>Arborgames</application> look like this:

              <programlisting>
                forestRaster = [ZoomRaster createBegin: [self getZone]];
                SET_WINDOW_GEOMETRY_RECORD_NAME (forestRaster);
                forestRaster = [forestRaster createEnd];

                [forestRaster setColormap: colormap];
                [forestRaster setZoomFactor: 4];
                [forestRaster setWidth: [forestModelSwarm getWorldSize] 
                Height: [forestModelSwarm getWorldSize]];
                [forestRaster setWindowTitle: "The Forest"];
                [forestRaster pack];
              </programlisting>


              This code should be viewed as foundation-building.  The
              <classname>ZoomRaster</classname> object is created, and
              the macro
              <function>SET_WINDOW_GEOMETRY_RECORD_NAME</function> is
              executed.  This means that, when the use clicks
              <guibutton>save</guibutton> on the control panel, the
              window position of the <varname>forestRaster</varname>
              object will be saved in a file in the user's account.
            </para>
          </formalpara>

          <para>
            To briefly summarize the effect of the other commands, we
            note the following.  The fourth line tells the new raster
            object to use the colormap we just created.  The fifth
            line controls the magnification of the display, which in
            this case is 4.  The sixth line asks the
            <varname>forestModelSwarm</varname> object to report back
            the horizontal and vertical dimensions of the grid on
            which trees exist and then uses those to set the width and
            height of the <classname>ZoomRaster</classname> object's
            display.  The eighth line gives the display window a name
            and the last line, which tells the
            <varname>forestRaster</varname> to
            <function>pack</function> itself, causes the display to be
            initialized according to the settings we just provided.
          </para>
        </listitem>

        <listitem><formalpara>
            <title>Map a Swarm Space object onto the <classname>ZoomRaster</classname></title>
            
            <para>
              By itself, a <classname>ZoomRaster</classname> is just a
              nice looking set of edges around a blank background.  In
              order to display things inside that window, we need to
              create a connection between the agents who live in the
              model swarm (and lower level swarms) and then display
              them in the observer swarm.  This is done most commonly
              by telling each agent that it lives in a Swarm object
              known as a <classname>Grid2d</classname>.  As the agent
              goes through its lifetime, one of its activities is to
              put itself at a position in the grid and then (possibly)
              erase itself from the old spot and put itself in the new
              spot.
            </para>
          </formalpara>

          <para>
            The Swarm protocol <classname>Object2dDisplay</classname>
            can handle the work of drawing the positions of agents in
            a <classname>Grid2d</classname> object on a
            <classname>ZoomRaster</classname>.  In the
            <application>Arborgames</application> example, the
            <varname>forestRaster</varname> is used by an object
            called <varname>treeDisplay</varname> which connects the
            agents in the <classname>Grid2d</classname> (which is
            passed through from the
            <varname>forestModelSwarm</varname>).
            
            <programlisting>
              treeDisplay = [Object2dDisplay createBegin: [self getZone]];
              [treeDisplay setDisplayWidget: forestRaster];
              [treeDisplay setDiscrete2dToDisplay: 
              [[forestModelSwarm getTheForest] getTreeGrid]]; 
              [treeDisplay setObjectCollection:
              [[forestModelSwarm getTheForest] getTreeList]]; 
              [treeDisplay setDisplayMessage: M(drawSelfOn:)];
              treeDisplay = [treeDisplay createEnd];
            </programlisting>

            This example is slightly more complicated than most,
            because the <classname>Grid2d</classname> object is not
            retrieved directly from
            <varname>forestModelSwarm</varname> , but rather from
            another object that is defined in the
            <varname>forestModelSwarm</varname> .  Except for that
            wrinkle, this is a standard example.  The
            <classname>Object2dDisplay</classname> protocol is told to
            use the <varname>forestRaster</varname> as its "display
            widget."  It is necessary to tell the
            <varname>treeDisplay</varname> which
            <classname>Grid2d</classname> to use, and this chore is
            accomplished by the setDiscrete2dDisplay command.
          </para>

          <para>
            Why the <function>setObjectCollection</function> message
            and the <function>setDisplayMessage</function> are used is
            interesting and important.  The
            <classname>Object2dDisplay</classname> protocol has a
            method called <function>display</function>, which can be
            put in a schedule by the user.  When the display method is
            executed, the <varname>treeDisplay</varname> (since it follows the
            <classname>Object2dDisplay</classname> protocol) will send
            each of the agent-objects in the
            <classname>Grid2d</classname> a message telling it to draw
            itself in the <varname>forestRaster</varname>. How does it
            tell the object to draw itself? We tell it how by passing
            it the selector for the agent-object's
            <function>drawSelfOn:</function> method.  Each agent must
            be able to respond to a message of this sort:

            <programlisting>
              
              [anAgent drawSelfOn: aRaster];
            </programlisting>

            The program will crash if each agent that is positioned in
            the <classname>Grid2d</classname> is not able to respond
            to <function>drawSelfOn:</function>.
          </para>

          <para>
            The message <literal>setObjectCollection:
              [[forestModelSwarm getTheForest] getTreeList]]</literal>
              is not strictly necessary and the program will run
              without it.  It may not run so quickly, however.
              Without this command, the <varname>treeDisplay</varname>
              will respond to the <function>display</function> message
              by searching in each possible position of the
              <classname>Grid2d</classname> and sending each object it
              finds the <function>drawSelfOn:</function> message.  If
              the grid is large relative to the number of agents, then
              this might be a very slow process. The
              <function>setObjectCollection</function> method
              eliminates the need for <varname>treeDisplay</varname>
              to search through the whole grid.  When the object
              collection is set, then the
              <varname>treeDisplay</varname> will simply go through
              the list of objects and tell each one to display itself.
          </para>

        </listitem>

        <listitem>
          <formalpara>
            <title>Tell the <classname>ZoomRaster</classname> Where to Send Clicks</title>

            <para>

              A <classname>ZoomRaster</classname> object is highly
              self-aware.  If you stop a simulation and right-click on
              an object, you may see a probe display pop up.  That
              does not happen by magic, of course.  It is necessary to
              tell the raster that, when there is a certain kind of
              click, that it is supposed to pass that click to some
              other object that knows what to do with it.  That's why
              there is a command like this in the
              <function>buildObjects</function> phase:

              <programlisting>
                [forestRaster setButton: ButtonRight 
                Client: treeDisplay 
                Message: M(makeProbeAtX:Y:)];
              </programlisting>

              The <varname>treeDisplay</varname> is told to make a
              probe for the object that exists at a particular point
              in the grid.
            </para>
          </formalpara>
        </listitem>

        <listitem>
          <formalpara>
            <title>Schedule the Display</title>

            <para>
              This is one of the aspects of Swarm that could use some
              standardization. In the schedule, one generally includes
              steps that erase the raster, then the
              <classname>Object2dDisplay</classname> is told to update
              itself by the <function>display</function> command, and
              then that display is drawn to the screen by telling the
              <classname>ZoomRaster</classname> to
              <function>drawSelf</function>.
            </para>
          </formalpara>

          <para>
            In a simple model, in which we only have one
            <classname>ZoomRaster</classname> to update, then the
            schedule could be as simple. In the
            <function>buildActions</function> part of the code, one
            could create an <classname>ActionGroup</classname> like
            this:

            <programlisting>
              displayActions = [ActionGroup create: self];
              [displayActions createActionTo: forestRaster message: M(erase)];
              [displayActions createActionTo: treeDisplay message:M(display)];
              [displayActions createActionTo: forestRaster message: M(drawSelf)];
            </programlisting>

            (Of course, that action group has to be put into a
            schedule, which will probably execute it at each time
            point.) The <function>buildActions</function> method in
            <application>arborgames</application> is a bit more
            complicated than that since a large number of displays are
            managed.
          </para>
        </listitem>

        <listitem>
          <formalpara>
            <title>Make sure the Agents Put Themselves in the Grid!</title>
            <para>
              Inside the code that creates the individual agents who
              are to be drawn on the grid, one must be careful to
              accomplish two things.  First, the
              <function>drawSelfOn:</function> method must be created.
              Second, if one wants to have a clickable
              <classname>ZoomRaster</classname> that allows agents to
              be probed, it is also vital to have the agents report
              their positions.
            </para>
          </formalpara>

          <para>
            It is fairly standard in Swarm models to manage this by
            creating a <classname>Grid2d</classname> object in the
            model swarm level and then, when an agent is created, use
            a <function>setWorld</function> method to notify the agent
            where it lives. In <application>heatbugs</application>,
            for example, each heatbug has a <function>step</function>
            method that controls how it searches for heat and moves to
            find a better spot.  When it has decided where to go, the
            heatbug puts "nil" at it spot in the grid where it used to
            be and then it puts itself at the new coordinates.  Here
            is the relevant code from <filename>Heatbug.m</filename>:

            <programlisting> 
              [world putObject: nil atX: x Y: y];
              [world putObject: self atX: newX Y: newY];
            </programlisting>
          </para>

          <para>
            In the <application>Arborgames</application> example, the
            trees don't consciously move themselves. Rather, they are
            created and destroyed according to a set of rules that put
            them in a spot for a while.  When a tree is created, it is
            added to the grid with this command that is in the
            <filename>Forest.m</filename> file:

            <programlisting>
              - addTree: aTree atX: (int) xVal Y: (int) yVal
              {
              [treeList addFirst: aTree];
              [treeGrid putObject: aTree atX: xVal Y: yVal];
              return self; 
              }
            </programlisting>

            Trees don't move (so far as we know), so the only need to
            update this tree's position arises when the tree dies. The
            <filename>Forest.m</filename> file creates a class of
            methods common to the different kinds of forests, and then
            the subclasses like <classname>MatureForest</classname>
            are created to provide additional detail.  There are
            methods that remove a tree from the simulation and take it
            off the grid.  The trees that are supposed to die are
            added to a Swarm list called the
            <varname>exitQ</varname>. For each timestep, the forest
            tells each kind of tree to do its
            <function>step</function> method, which adds trees to the
            <varname>exitQ</varname> list, and then the forest's
            <function>step</function> method removes those trees from
            the grid. In the <filename>MatureForest.m</filename> file,

            <programlisting>
              -step {
              id aTree, index ;

              [treeList forEach: M(step)] ;

              index = [exitQ begin: [self getZone]] ;
              while( (aTree = [index next]) ){
              [treeList remove: aTree] ;
              [treeGrid putObject: nil atX: [aTree getX] Y: [aTree getY]] ;
              [index remove] ;
              [aTree drop] ;
              }
              [index drop] ;
              return self ;
              }
            </programlisting>

          </para>
        </listitem>
      </orderedlist>
    </para>
  </sect2>

</sect1>
<!-- 
Local Variables: sgml-parent-document:("userbook.sgml" "SECT1")
End: 
-->
