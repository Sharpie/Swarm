// Swarm library. Copyright (C) 1996-1998 Santa Fe Institute.
// This library is distributed without any warranty; without even the
// implied warranty of merchantability or fitness for a particular purpose.
// See file LICENSE for details and terms of copying.

#import <analysis.h>
#import <simtools.h> // OutFile, ActiveOutFile
#import <simtoolsgui.h> // ActiveGraph

#define NUMCOLORS 10
const char graphColors[NUMCOLORS][16] = { "Red", "Green", "Yellow", 
                                          "Pink", "SeaGreen", "Magenta", 
                                          "Purple", "DarkGreen", "Goldenrod", 
                                          "Black" };

@implementation EZGraph

+ createBegin: aZone
{
  EZGraph *obj;

  obj = [super createBegin: aZone];
  obj->graphics = 1;
  obj->fileOutput = 0;
  obj->title = NULL;
  obj->xLabel = NULL;
  obj->yLabel = NULL;
  return obj;
}

//* The setGraphics method sets the state of the display. Set the state to 0 
//* if a graphical display of the graph is not required. The default state is 1
//* meaning that by default the data appears graphically in a window. 
- setGraphics: (int)state
{
  graphics = state;
  return self;
}

//* The setFileOutput method sets the state of file I/O.  Set the state to 1 
//* if data for the sequences is to be sent to a file.  The default state is 0
//* meaning that by default no file I/O is carried out by the EZGraph class.
- setFileOutput: (int)state
{
  fileOutput = state;
  return self;
}

//* The setAxisLabels:X:Y method sets the horizontal and vertical labels on 
//* the histogram in the graphical version of EZGraph. (Only relevant if the 
//* state of setGraphics is set to 1.)
- setAxisLabelsX: (const char *)xl Y:(const char *)yl
{ 
  xLabel = xl;
  yLabel = yl;
  return self;
}

//* The setTitle method uses a title string to label a graph window in the 
//* graphical version of EZGraph.  The label appears at the top of the graph 
//* window. (Only relevant if the state of setGraphics is set to 1.)
- setTitle: (const char *)aTitle
{
  title = aTitle;
  return self;
}

- createEnd
{

  if (graphics)
    {
      theGraph = [Graph createBegin: [self getZone]];
      SET_COMPONENT_WINDOW_GEOMETRY_RECORD_NAME (theGraph);
      theGraph = [theGraph createEnd];
      [theGraph setTitle: title];
      [theGraph setAxisLabelsX: xLabel Y: yLabel];
      [theGraph pack];
    }
  
  sequenceList = [List create: [self getZone]];
  
  return self;
}

//* The getGraph method lets the user access the graph generated internally
//* by the EZGraph. (Only relevant if the state of setGraphics is set to 1.)
- getGraph
{
  return theGraph;
}

// internal method called by createSequence:withFeedFrom:andSelector
- createGraphSequence: (const char *)aName
          forSequence: aSeq
         withFeedFrom: anObj 
          andSelector: (SEL)aSel
{
  id aGrapher;
  
  if (graphics)
    {
      id anElement;
      
      anElement = [theGraph createElement];
      [anElement setLabel: aName];
      [anElement setColor: graphColors[colorIdx++ % NUMCOLORS]];

      aGrapher = [ActiveGraph createBegin: [self getZone]];
      [aGrapher setElement: anElement];
      [aGrapher setDataFeed: anObj]; 
      [aGrapher setProbedSelector: aSel];
      aGrapher = [aGrapher createEnd];
      
      [aSeq setActiveGrapher: aGrapher];    
    }
 
  if (fileOutput)
    {
      id aFileObj;
      
      aFileObj = [OutFile create: [self getZone] withName: aName];
      
      aGrapher = [ActiveOutFile createBegin: [self getZone]];
      [aGrapher setFileObject: aFileObj];
      [aGrapher setDataFeed: anObj]; 
      [aGrapher setProbedSelector: aSel];
      aGrapher = [aGrapher createEnd];
      
      [aSeq setActiveOutFile: aGrapher];    
    }
  
  [sequenceList addLast: aSeq];
  
  return self;
}

//* The createSequence method creates a sequence in the EZGraph based on
//* the return value provided by the object anObj when sent the selector
//* aSel.  If file I/O is enabled, then the data will be sent to a file with
//* the name aName, otherwise the aName argument is simply used as the
//* legend for the graph element generated by EZGraph.
- createSequence: (const char *)aName
    withFeedFrom: anObj 
     andSelector: (SEL)aSel
{
  id aSeq;
  
  aSeq = [EZSequence create: [self getZone]];

  [self createGraphSequence: aName forSequence: aSeq
	withFeedFrom: anObj andSelector: aSel];
  
  return self;
}

//* The createAverageSequence method takes a collection of objects and 
//* generates a sequence based on the average over the responses of the
//* entire object set (as opposed to a single object as in createSequence)
- createAverageSequence: (const char *)aName 
           withFeedFrom: aCollection 
            andSelector: (SEL)aSel
{
  id aSeq;
  id anAverager;
  
  aSeq = [EZAverageSequence create: [self getZone]];
  
  anAverager = [Averager createBegin: [self getZone]];
  [anAverager setCollection: aCollection];
  [anAverager setProbedSelector: aSel];
  anAverager = [anAverager createEnd];

  [aSeq setAverager: anAverager];

  [self createGraphSequence: aName forSequence: aSeq
	withFeedFrom: anAverager 
	andSelector: M(getAverage)];

  return self;
}

//* The createTotalSequence method takes a collection of objects and 
//* generates a sequence based on the sum over the responses of the
//* entire object set (as opposed to a single object as in createSequence)
- createTotalSequence: (const char *)aName
         withFeedFrom: aCollection 
          andSelector: (SEL)aSel
{
  id aSeq;
  id anAverager;
  
  aSeq = [EZAverageSequence create: [self getZone]];
  
  anAverager = [Averager createBegin: [self getZone]];
  [anAverager setCollection: aCollection];
  [anAverager setProbedSelector: aSel];
  anAverager = [anAverager createEnd];

  [aSeq setAverager: anAverager];

  [self createGraphSequence: aName forSequence: aSeq
	withFeedFrom: anAverager 
	andSelector: M(getTotal)];

  return self;
}

//* The createMinSequence method takes a collection of objects and 
//* generates a sequence based on the minimum over the responses of the
//* entire object set (as opposed to a single object as in createSequence)
- createMinSequence: (const char *)aName 
       withFeedFrom: aCollection 
        andSelector: (SEL)aSel
{
  id aSeq;
  id anAverager;

  aSeq = [EZAverageSequence create: [self getZone]];

  anAverager = [Averager createBegin: [self getZone]];
  [anAverager setCollection: aCollection];
  [anAverager setProbedSelector: aSel];
  anAverager = [anAverager createEnd];

  [aSeq setAverager: anAverager];

  [self createGraphSequence: aName forSequence:aSeq
	withFeedFrom: anAverager 
	andSelector: M(getMin)];

  return self;

}

//* The createMaxSequence method takes a collection of objects and 
//* generates a sequence based on the maximums over the responses of the
//* entire object set (as opposed to a single object as in createSequence)
- createMaxSequence: (const char *)aName
       withFeedFrom: aCollection 
        andSelector: (SEL)aSel
{
  id aSeq;
  id anAverager;

  aSeq = [EZAverageSequence create: [self getZone]];

  anAverager = [Averager createBegin: [self getZone]];
  [anAverager setCollection: aCollection];
  [anAverager setProbedSelector: aSel];
  anAverager = [anAverager createEnd];

  [aSeq setAverager: anAverager];

  [self createGraphSequence: aName forSequence: aSeq
	withFeedFrom: anAverager 
	andSelector: M(getMax)];

  return self;

}

//* The createCountSequence method takes a collection of objects and 
//* generates a sequence based on the count over the responses of the
//* entire object set (as opposed to a single object as in createSequence)
- createCountSequence: (const char *)aName
         withFeedFrom: aCollection 
          andSelector: (SEL) aSel
{
  id aSeq;
  id anAverager;
  
  aSeq = [EZAverageSequence create: [self getZone]];
  
  anAverager = [Averager createBegin: [self getZone]];
  [anAverager setCollection: aCollection];
  [anAverager setProbedSelector: aSel];
  anAverager = [anAverager createEnd];

  [aSeq setAverager: anAverager];

  [self createGraphSequence: aName
        forSequence: aSeq
	withFeedFrom: anAverager 
	andSelector: M(getCount)];
  
  return self;

}

//* The step method lets the user accest the graph generated internally by
//* EZGraph. (Only relevant if the state of setGraphics is set to 1.)
- step
{
  [sequenceList forEach: M(step)];
  return self;
}

- (void)drop
{
  id index, aSequence;
  
  [theGraph drop];

  index = [sequenceList begin: [self getZone]];
  while ((aSequence = [index next]))
    {
      [index remove];
      [aSequence drop];
    }
  [index drop];
  [super drop];
}

@end


@implementation EZSequence

- setActiveOutFile: anActiveOutFile
{
  theActiveOutFile = anActiveOutFile;
  return self;
}

- setActiveGrapher: aGrapher
{
  theActiveGrapher = aGrapher;
  return self;
}

- step
{
  if (theActiveGrapher)
    [theActiveGrapher step];
  
  if (theActiveOutFile)
    [theActiveOutFile step];
  
  return self;
}

- (void)drop
{
  [theActiveGrapher drop];
  [theActiveOutFile drop];
  [super drop];
}

@end 


@implementation EZAverageSequence

- setAverager: anAverager
{
  theAverager = anAverager;
  return self;
}

- step
{
  [theAverager update];
  [super step];
  
  return self;
}

- (void)drop
{
  [theAverager drop];
  [super drop];
}

@end 
