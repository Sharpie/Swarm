// --------------------------------------------
//
// Random v. 0.7 (Swarm 1.0.3)
//
// Notes on the use of the distribution objects
//
// Sven Thommesen <sthomme@humsci.auburn.edu>
//
// 1997-09-01
//
// --------------------------------------------

IMPROVEMENTS over v. 0.6:

One new distribution class, BernoulliDist, has been added. It returns 
binary values (yes/true/1) with a given probability (while the old
RandomBitDist has a fixed 50% probability, a fair coin toss.)

Distributions now have a new create method, '+createWithDefaults: aZone'.
This method creates the distribution object, and also a new generator
object for its exclusive use. Each distribution class has a different
default generator class assigned. These generators are initialized with
STARTSEED, which by default equals the fixed value DEFAULTSEED, but will
be equal to the varying RANDOMSEED if you start your program with the
command line parameter '-varySeed'.

All distributions have code to interact with the new 'split' generators.

UniformIntegerDist and UniformUnsignedDist now allow you to set parameter
minValue equal to maxValue. In this case that value is returned every time.

UniformDoubleDist also allows this, even if the set [x,x) is mathematically
suspect ...

NormalDist and LogNormalDist now allow you to specify zero Variance, in
which case the values returned are the Mean and exp(Mean) respectively.


CHANGES since v. 0.6:

The distribution classes have changed names to where they all end
in 'Dist'. A simple search-and-replace in your code will get you
back up and running.

The strong distinction between 'frozen' and 'un-frozen' distribution
objects in v. 0.6 has been softened considerably. You may now set and
reset the default parameters as often as you wish, and you may make
calls for variates with given parameters even if different default
parameters have been set.

The generation of uniform(0,1) floating point values has been
moved from the distribution objects into the generator objects.
Thus, if all you need is a uniform(0,1) double, you have no need
of a distribution but can get what you desire from a generator.

Note that the generators fill the mantissa of a double from two
32-bit unsigned values in a different manner from v. 0.6 distributions,
so output will be a bit different in the new version.

A bug in LogNormalDist has been fixed.

The 'getState:' method has been named 'putStateInto: (void *) buffer',
and the 'setState:' method is now 'setStateFrom: (void *) buffer. A quick
search-and-replace fixes things in your code.

But note: these methods have also changed somewhat, as has the size of
the data being saved. As a result, v. 0.7 distributions will refuse to
'setStateFrom' data saved by v. 0.6 objects.

There should be fewer changes like this in the next release.


USAGE notes:
------------

Each distribution object must be assigned a random generator
on creation. You may not re-assign generators to a distribution after it
has been created. You may, however, connect more than one distribution
object to one generator, so that they end up drawing output from the
generator in an interleaved fashion. Or you may create a new generator
for each distribution object.

Each distribution has its own set of (1-2) parameters. You may deal with 
these parameters in two different ways: (1) you assign a set of default 
parameter values to the object on creation, and draw from the distribution
using those parameters. Or (2), you may refrain from assigning default 
parameters, in which case you must specify the (possibly different) desired 
parameters on each call. You can (re-)set the default parameters any time, 
and you may call for a variate with specified parameter values even if 
different default parameters have been set.

Just like the generator objects, the distribution objects allow you to 
save and later restore their internal state.


Where I use NormalDistribution in examples below, substitute any other
distribution and its parameters as needed.

NOTE: any name that starts with 'my' is meant to designate a variable
which you have defined in your own program.


You create a distribution in one of several ways:

(a) the lazy way:

   myNormalDist = [ NormalDist createWithDefaults: [self getZone]];

This method will create a distribution object with no default
parameters set, as well as a fresh generator object connected to it. The
generator object is initialized with STARTSEED (see the discussion above).
Different distribution classes use different generators for this purpose.

(b) Without default parameters, using a simple generator:

   myNormalDist = [ NormalDist create: [self getZone]
			setGenerator: mySimpleGenerator ];

'myGenerator' must of course first have been set to point to a random
generator of the 'simple' type. Note that you cannot assign a different 
generator to a distribution after it has been created.

You can create the generator at the same time as the distribution:

   myNormalDist = [ NormalDist create: [self getZone]
		setGenerator: [TT800gen create: [self getZone] 
				setStateFromSeed: 34453]         ];

(c) Without default parameters, using a split generator:

   myNormalDist = [ NormalDist create: [self getZone]
			setGenerator: mySplitGenerator
			setVirtualGenerator: 7 ];

or perhaps

   myNormalDist = [ NormalDist create: [self getZone]
		setGenerator: [C4LCGXgen createWithDefaults: [self getZone]]
			setVirtualGenerator: 99 ];

A split generator can be thought of as comprising a set of virtual 
generators (streams of random numbers), and a distribution object must be
'connected' to one of these streams. You cannot re-assign the generator
or the virtual generator after a distribution object has been created.

In all these cases (a) - (c), when we want to obtain a random variate from
this distribution object we need to specify the parameters:

   myDouble = [ myNormalDist getSampleWithMean: 3.3 withVariance: 1.7];

You can use different parameters for every call. (And you can use this call
even if default parameters have been set.)


(d) With default parameters, using a simple generator:

   myNormalDist = [ NormalDist create: [self getZone]
			setGenerator: mySimpleGenerator
			setMean: 7.6 setVariance: 1.2 ];

(e) With default parameters, using a split generator:

   myNormalDist = [ NormalDist create: [self getZone]
			setGenerator: mySplitGenerator
			setVirtualGenerator: 33
			setMean: 3.2 setVariance: 2.1 ];

In these cases, we do not need to specify parameters to get a random number:

   myDouble = [ myNormalDist getDoubleSample ];

However, you *are* allowed to specify parameters even if default parameters
have been set.

( Of course, different distributions have different parameters: RandomBitDist
has none, the Uniform objects have minimum and maximum limit values, NormalDist
and LogNormalDist use Mean and Variance, ExponentialDist only Mean, and
GammaDist used alpha and beta. See the file random/distributions.h for the
specific methods available. )


(f) You may reset the default parameters this way, as often as you like:

   [ myNormalDist setMean: 3.3 setVariance: 2.2 ];


(g) You can obtain the current values of parameters:

   // Default parameters:
   myDouble1 = [ myNormalDist getMean ];
   myDouble2 = [ myNormalDist getVariance ];
   myDouble3 = [ myNormalDist getStdDev ];

   // Get a pointer to the generator object:
   myOtherGenerator = [ myNormalDist getGenerator ];

   // Get the number of the virtual generator (if a split generator is used):
   myUnsignedValue  = [ myNormalDist getVirtualGenerator];

   // Find out if default parameters have been set:
   myBoolean        = [ myNormalDist getOptionsInitialized ];

   // Find out how many variates the object has delivered so far:
   // (The counter is an unsigned long long int, which goes up to 2^64.)
   myLongLongInt    = [ myNormalDist getCurrentCount ];


(h) You can reset the variate counter and other state variables this way:
   [ myNormalDist reset ];

   This is most likely done in conjunction with resetting the connected
   generator, using [ myGenerator setStateFromSeed: mySeedValue ];


(i) Finally, we have the InternalState protocol methods:

   // Print (most of) the object's state data to a stream:
   [ myNormalDist describe: myStream ];

The stream myStream may be created thus:
id myStream = [ OutStream create: [self getZone] setFileStream: stdout ]; or
id myStream = [ OutStream create: [self getZone] setFileStream: stderr ];

   // Get the (class) name of the object:
   myString = [ myNormalDist getName ];

   // Get the object's 'magic number', used by putStateInto / setStateFrom:
   myUnsigned = [ myNormalDist getMagic ];

You may save, and later restore, the internal state of a distribution object
using these methods:

   // Get the size of the memory buffer needed by putStateInto / setStateFrom:
   myUnsigned = [ myNormalDist getStateSize ];

   // Extract the distribution's state data into your memory buffer:
   [ myNormalDist putStateInto: myBuffer ];

   // Set the distribution's state from data in a memory buffer:
   [ myNormalDist setStateFrom: myBuffer ];


To illustrate, assume the following data definitions:

   FILE * myFile;
   char * myFileName = "MyDistFile.bin"; // or whatever
   int stateSizeD;
   id stateBufD;
   int status;

The following code shows how to save an object's state to disk:
(You should add your own code to deal with disk file errors,
either aborting or printing out error messages.)

   // Ask how big a buffer we need:
   stateSizeD = [ myNormalDist getStateSize ];

   // Allocate memory for the buffer:
   stateBufD  = [[self getZone] alloc: stateSizeD];

   // Ask the distribution object to put state data into the buffer:
   [ myNormalDist putStateInto: (void *) stateBufD ];

   // Open a disk file for output:
   myFile = fopen(myFileName, "w");
   if (myFile == NULL) { };	// error on open: disk full, or no permissions

   // Write the state buffer to disk in binary form:
   status = fwrite(stateBufD, stateSizeD, 1, myFile);
   if (status < 1) { };		// error on write: disk full?

   // Close the file
   status = fclose(myFile);
   if (status) { };		// error on close ?

   // Free the memory allocated to the buffer:
   [[self getZone] free: stateBufD];

   // Or, for test purposes, just zero the buffer data instead:
   // memset(stateBufD, 0, stateSizeD);


This code shows how to set an object's state from a disk file:

   // Ask how big a buffer we need:
   stateSizeD = [ myNormalDist getStateSize ];

   // Allocate memory for the buffer:
   stateBufD  = [[self getZone] alloc: stateSizeD];

   // Open a disk file for input:
   myFile = fopen(myFileName, "r");
   if (myFile == NULL) { };	// error on open: file not found

   // Read state data into the memory buffer:
   status = fread(stateBufD, stateSizeD, 1, myFile);
   if (status < 1) { };		// error on read

   // Close the file:
   status = fclose(myFile);
   if (status) { };		// error on close

   // Ask the distribution object to set its state from the buffer data:
   [ myNormalDist setStateFrom: (void *) stateBufD ];

   // Free the memory allocated to the buffer:
   [[self getZone] free: stateBufD];



UTILITY OBJECTS PROVIDED:

The following objects have been defined in <random/random.m>, and are
immediately accessible from anywhere in your program:

id <MT19937>             randomGenerator;
id <UniformIntegerDist>   uniformIntRand;
id <UniformUnsignedDist>  uniformUnsRand;
id <UniformDoubleDist>    uniformDblRand;

The 3 distribution objects all draw their random numbers from the MT19937
generator, which has a period of 2^19937 (10^6001) and is quite fast.


